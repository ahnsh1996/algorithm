# [프로그래머스] 섬 연결하기
## 문제
### 문제 설명
([원본 문제](https://programmers.co.kr/learn/courses/30/lessons/42861)의 내용을 복사한 것입니다.)

n개의 섬 사이에 다리를 건설하는 비용(costs)이 주어질 때, 최소의 비용으로 모든 섬이 서로 통행 가능하도록 만들 때 필요한 최소 비용을 return 하도록 solution을 완성하세요.

다리를 여러 번 건너더라도, 도달할 수만 있으면 통행 가능하다고 봅니다. 예를 들어 A 섬과 B 섬 사이에 다리가 있고, B 섬과 C 섬 사이에 다리가 있으면 A 섬과 C 섬은 서로 통행 가능합니다.

### 제한사항
* 섬의 개수 n은 1 이상 100 이하입니다.
* costs의 길이는 ```((n-1) * n) / 2```이하입니다.
* 임의의 i에 대해, costs[i][0] 와 costs[i] [1]에는 다리가 연결되는 두 섬의 번호가 들어있고, costs[i] [2]에는 이 두 섬을 연결하는 다리를 건설할 때 드는 비용입니다.
* 같은 연결은 두 번 주어지지 않습니다. 또한 순서가 바뀌더라도 같은 연결로 봅니다. 즉 0과 1 사이를 연결하는 비용이 주어졌을 때, 1과 0의 비용이 주어지지 않습니다.
* 모든 섬 사이의 다리 건설 비용이 주어지지 않습니다. 이 경우, 두 섬 사이의 건설이 불가능한 것으로 봅니다.
* 연결할 수 없는 섬은 주어지지 않습니다.

### 입출력 예
|n|costs|return|
|:---:|:---:|:---:|
|4|[[0,1,1],[0,2,2],[1,2,5],[1,3,1],[2,3,8]]|4|

### 입출력 예 설명

costs를 그림으로 표현하면 다음과 같으며, 이때 초록색 경로로 연결하는 것이 가장 적은 비용으로 모두를 통행할 수 있도록 만드는 방법입니다.

![입출력 예](https://user-images.githubusercontent.com/77680436/105997864-6bfb1780-60ef-11eb-9c92-e4aff3ed7798.png)

## 제출답안
```python
def find(x, parent): # 해당 원소가 어떤 집합(그래프)에 속해있는지 판별
    if parent[x] != x: return find(parent[x], parent)
    return x

def union(x, y, parent): # 두 개의 집합(그래프)을 병합
    x_root = find(x, parent)
    y_root = find(y, parent)
    parent[x_root] = y_root

def solution(n, costs):
    answer = 0
    parent = [i for i in range(n)]
    costs.sort(key=lambda x: x[2]) # 비용을 기준으로 간선(다리)을 오름차순 정렬

    count = 0
    for i in costs:
        if find(i[0], parent) != find(i[1], parent): # 두 섬이 서로 같은 그래프에 속해있는지(사이클을 형성하는지) 판별
            answer += i[2]
            count += 1
            if count == n-1: break # 노드(섬)의 수-1 개의 간선을 모두 선택했다면 반복 종료
            union(i[0], i[1], parent)

    return answer
```
### 설명
본 문제의 경우 유명한 알고리즘 중 하나인 Kruskal 알고리즘을 적용하여 풀 수 있는 문제이다. Kruskal 알고리즘은 최소비용 신장 트리를 구하는 알고리즘인데, 
여기서 **신장 트리는 원래 그래프의 부분 그래프로, 모든 노드가 가능한 최소의 간선 수를 통해 연결된 그래프**를 말한다. 
**최소비용 신장 트리는 최소의 비용을 갖는 신장 트리**로, 다음의 제한적인 조건을 갖는다.
* 그래프 내의 간선들만을 사용해야 한다.
* 노드의 수-1 개의 간선만을 포함해야 한다.
* 사이클을 포함하지 않는다.(특정 노드에서 출발하여 다시 해당 노드로 돌아갈 수 있는 경로가 있다면 사이클이 존재하는 것이다.)

본 문제에서 요구하는 최소한의 비용으로 모든 섬을 연결한 결과는 이러한 최소비용 신장 트리의 형태를 띠게 되기 때문에, Kruskal 알고리즘을 이용하여 문제를 해결할 수 있다.
Kruskal 알고리즘은 거리가 짧은 간선부터 그래프에 포함시키려는 개념으로, 다음과 같은 과정을 거친다.

1. 그래프의 간선들을 비용(다리 건설 비용)을 기준으로 오름차순으로 정렬한다.
2. 정렬된 순서대로(비용이 작은 것부터) 간선을 선택해 사이클을 형성하지 않는다면 그래프에 포함시킨다.
3. 최소비용 신장 트리가 완성될 때까지 2번 과정을 반복한다.

여기서 사이클을 형성하지 않는지 확인하기 위해서는 Union-Find 자료구조의 Union, Find 연산을 사용한다. Union-Find 자료구조는 서로소 집합(disjoint-set) 자료 구조라고도 불리는데, 
서로소 집합은 공통 원소가 없는 두 집합(A∩B = ø)을 말한다. Union-Find 자료구조의 Find 연산은 해당 원소가 어떤 집합에 속해있는지 판별하는 연산이며, Union 연산은 두 개의 집합을 병합하는 연산이다. 
여기서 집합을 하나의 그래프로, 원소를 노드로 본다면 Find 연산을 통해 해당 노드가 어떤 그래프에 속하는지 확인할 수 있고, Union 연산을 통해 두 그래프를 하나의 그래프로 합칠 수 있다. 

이를 이용하여 Kruskal 알고리즘을 다시 나타내면 다음과 같으며, 이를 구현하여 최소비용을 구한 것이 제출답안이다.(위의 2번 과정이 여기서의 2-3번 과정이다.)

1. 그래프의 간선들을 비용(다리 건설 비용)을 기준으로 오름차순으로 정렬한다.
2. 정렬된 순서대로 간선을 선택 후, Find 연산을 통해 간선의 두 노드가 같은 그래프에 속하는지 확인한다.</br>(같은 그래프의 노드가 아니라면 연결하여도 사이클을 형성하지 않음)
3. 사이클을 형성하지 않는다면 Union 연산을 통해 그래프에 포함시킨다.
4. 최소비용 신장 트리가 완성될 때까지 2-3번 과정을 반복한다.
