# [프로그래머스] 이중우선순위큐
## 문제
### 문제 설명
([원본 문제](https://programmers.co.kr/learn/courses/30/lessons/42628)의 내용을 복사한 것입니다.)

이중 우선순위 큐는 다음 연산을 할 수 있는 자료구조를 말합니다.

|명령어|연산 내용|
|:---:|:---:|
|I 숫자|큐에 주어진 숫자를 삽입합니다.|
|D 1|큐에서 최댓값을 삭제합니다.|
|D -1|큐에서 최솟값을 삭제합니다.|

(원본에서는 '연산 내용'이 '수신 탑(높이)'으로 되어 있었으나 오타로 생각되어 임의로 수정하였다.)

이중 우선순위 큐가 할 연산 operations가 매개변수로 주어질 때, 모든 연산을 처리한 후 큐가 비어있으면 [0,0] 비어있지 않으면 [최댓값, 최솟값]을 return 하도록 solution 함수를 구현해주세요.

### 제한사항
* operations는 길이가 1 이상 1,000,000 이하인 문자열 배열입니다.
* operations의 원소는 큐가 수행할 연산을 나타냅니다.
  * 원소는 “명령어 데이터” 형식으로 주어집니다. - 최댓값/최솟값을 삭제하는 연산에서 최댓값/최솟값이 둘 이상인 경우, 하나만 삭제합니다.
* 빈 큐에 데이터를 삭제하라는 연산이 주어질 경우, 해당 연산은 무시합니다.

### 입출력 예
|operations|return|
|:---:|:---:|
|["I 16", "D 1"]|[0, 0]|
|["I 7", "I 5", "I -5", "D -1"]|[7, 5]|

### 입출력 예 설명
16을 삽입 후 최댓값을 삭제합니다. 비어있으므로 [0, 0]을 반환합니다.  
7, 5, -5를 삽입 후 최솟값을 삭제합니다. 최대값 7, 최소값 5를 반환합니다.

## 제출답안
```python
def solution(operations):
    queue = []
    for op in operations:
        if op[0] == 'I': # 숫자 삽입
            idx = 0
            while idx < len(queue) and int(op[2:]) > queue[idx]: idx += 1 # 숫자가 삽입될 위치를 찾음
            queue = queue[:idx] + [int(op[2:])] + queue[idx:]
        elif op[2] == '-': queue = queue[1:] # 최솟값 삭제
        else: queue = queue[:len(queue)-1] # 최댓값 삭제

    return [queue[-1], queue[0]] if queue else [0, 0] # 큐가 비었다면 [0, 0], 그렇지 않다면 [최댓값, 최솟값] 반환
```
### 설명
사실 내가 제출한 답안은 원래의 의도와는 많이 달라 틀려야 한다고 생각한다. 하지만 본 문제가 유독 테스트 케이스가 부족하여, 시간복잡도를 크게 고려하지 않아도 답만 맞으면 통과시키는 바람에 
내 코드도 통과되었다. 그래도 원래의 의도대로 힙을 이용해서 풀지 않는다면 가장 직관적이고 간단하게라도 짜야겠다고 생각하여 작성한 답안이다.

위의 답안의 풀이는 간단하다. 삽입 정렬과 같이 원소의 삽입 시에는 오름차순 정렬했을 때 큐에서 자신이 들어갈 위치를 찾아 해당 위치에 원소를 삽입한다. 이렇게 하면 큐는 항상 정렬된 상태가 
되므로 큐의 맨 앞 원소는 최솟값, 맨 마지막 원소는 최댓값이 된다. 따라서 최소, 최대를 삭제할 때도 큐의 끝만 지우면 되며, 최종 결과를 낼 때도 끝만 확인하면 되기 때문에 간단하다.

예를 통해 삽입 과정을 살펴보면 다음과 같다.  
(입력 = ["I -45", "I 653", "I -642", "I 45", "I 97", "I 333"])

|삽입할 숫자|삽입할 인덱스|삽입할 위치|
|:---:|:---:|:---|
|-45|0|[□]|
|653|1|[-45, □]|
|-642|0|[□, -45, 653]|
|45|2|[-642, -45, □, 653]|
|97|3|[-642, -45, 45, □, 653]|
|333|4|[-642, -45, 45, 97, □, 653]|

위와 같은 과정을 거쳐 [-642, -45, 45, 97, 333, 653] 이라는 리스트가 완성된다. 여기서 매 과정을 살펴보면 항상 정렬된 상태를 유지하여 맨 끝이 최소와 최대가 되는 것을 볼 수 있다.

## 개선사항
위에서도 언급하였듯이 본 문제의 경우 원래 힙을 이용하여 풀어야 하는 문제이나 테스트 케이스가 빈약하여 답만 맞으면 거의 통과되는 수준이었다. 그래서 힙을 이용한 사람들의 풀이 중에 모범 
답안이라도 소개하고자 하였으나, 부족한 테스트 케이스로 인해 대부분 힙을 이용하였더라도 max()를 사용하거나 시간복잡도 상 굳이 힙을 이용한 이점이 없는 코드 등이 대다수였다..

그래도 프로그래머스에서 가장 추천을 많이 받은 코드가 가장 의도에 맞게 짜신 코드 같아서 이를 소개하면 다음과 같다.
```python
from heapq import heappush, heappop

def solution(arguments):
    max_heap = []
    min_heap = []
    for arg in arguments:
        if arg == "D 1":
            if max_heap != []:
                heappop(max_heap)
                if max_heap == [] or -max_heap[0] < min_heap[0]:
                    min_heap = []
                    max_heap = []
        elif arg == "D -1":
            if min_heap != []:
                heappop(min_heap)
                if min_heap == [] or -max_heap[0] < min_heap[0]:
                    max_heap = []
                    min_heap = []
        else:
            num = int(arg[2:])
            heappush(max_heap, -num)
            heappush(min_heap, num)
    if min_heap == []:
        return [0, 0]
    return [-heappop(max_heap), heappop(min_heap)]
```
