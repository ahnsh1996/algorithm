# [프로그래머스] 등굣길
## 문제
### 문제 설명
([원본 문제](https://programmers.co.kr/learn/courses/30/lessons/42898)의 내용을 복사한 것입니다.)

계속되는 폭우로 일부 지역이 물에 잠겼습니다. 물에 잠기지 않은 지역을 통해 학교를 가려고 합니다. 집에서 학교까지 가는 길은 m x n 크기의 격자모양으로 나타낼 수 있습니다.

아래 그림은 m = 4, n = 3 인 경우입니다.

![설명](https://user-images.githubusercontent.com/77680436/110758039-661c5880-828f-11eb-9c1a-ccac0b91459b.png)

가장 왼쪽 위, 즉 집이 있는 곳의 좌표는 (1, 1)로 나타내고 가장 오른쪽 아래, 즉 학교가 있는 곳의 좌표는 (m, n)으로 나타냅니다.

격자의 크기 m, n과 물이 잠긴 지역의 좌표를 담은 2차원 배열 puddles이 매개변수로 주어집니다. 오른쪽과 아래쪽으로만 움직여 집에서 학교까지 갈 수 있는 최단경로의 개수를 1,000,000,007로 나눈 나머지를 return 하도록 solution 함수를 작성해주세요.

### 제한사항
* 격자의 크기 m, n은 1 이상 100 이하인 자연수입니다.
  * m과 n이 모두 1인 경우는 입력으로 주어지지 않습니다.
* 물에 잠긴 지역은 0개 이상 10개 이하입니다.
* 집과 학교가 물에 잠긴 경우는 입력으로 주어지지 않습니다.

### 입출력 예
|m|n|puddles|return|
|:---|:---|:---|:---|
|4|3|[[2, 2]]|4|

### 입출력 예 설명
![예시 설명](https://user-images.githubusercontent.com/77680436/110759383-e5f6f280-8290-11eb-8f6d-2947fb5fe9c4.png)

## 제출답안
```python
def solution(m, n, puddles):
    # 리스트의 각 값은 해당 좌표까지 가기위한 최단경로의 개수를 의미
    d = [[0]*m for _ in range(n)]
    d[0][0] = 1 # 시작점을 1로 초기화

    for y, x in puddles: d[x-1][y-1] = -1 # 물 웅덩이를 표시
        
    for i in range(n):
        for j in range(m):
            if d[i][j] != -1: # 물 웅덩이가 아닌 곳이면
                if d[i-1][j] != -1: # 자신의 왼쪽이 물 웅덩이가 아니면
                    d[i][j] += d[i-1][j] # 자신의 왼쪽으로 올 수 있는 경로의 수를 더함
                if d[i][j-1] != -1: # 자신의 위쪽이 물 웅덩이가 아니면
                    d[i][j] += d[i][j-1] # 자신의 위쪽으로 올 수 있는 경로의 수를 더함

    return d[n-1][m-1] % 1000000007
```
### 설명
본 문제의 경우 다음과 같은 점화식을 세워 해결할 수 있다.
```
d(x, y) = x, y 좌표까지 가기위한 최단경로의 개수
단, x와 y는 자연수

(1) x = 1, y > 1일 때,
d(x, y) = d(x, y-1)

(2) x > 1, y = 1일 때,
d(x, y) = d(x-1, y)

(3) x > 1, y > 1일 때,
d(x, y) = d(x-1, y) + d(x, y-1)
```
사실 간단히 (3)이라고 생각하여도 문제는 없다. 하지만, 정확하게는 왼쪽 끝이거나 위쪽 끝인 경우에는 그 이전의 좌표가 존재하지 않기 때문에 나누어 주었다.

이를 소스 코드로 구현하면 제출답안과 같다. 물 웅덩이의 경우 갈 수 있는 경로가 없으므로 사실 상 d(x, y)의 값은 0으로 취급하지만 답안에서는 -1로 표시하여 물 웅덩이를 구분하였다.
여기서 원래대로라면 d(x, y)에서 x, y는 자연수라는 조건 때문에 비교를 다음과 같이 해야 할 것이다.
```python
if i > 0 and d[i-1][j] != -1: # 자신의 왼쪽이 물 웅덩이가 아니면
if j > 0 and d[i][j-1] != -1: # 자신의 위쪽이 물 웅덩이가 아니면
```
쉽게 말해서 인덱스가 음수가 되어 잘못 더해지거나 오류가 발생하는 경우를 초래하지 않기 위해서이다.  
(ex. d[1][-1] 과 같이 참조하여 오류가 발생하거나 예기치 못한 결과가 발생하는 것을 방지하기 위해서이다.)

하지만 적어도 파이썬에서는 답안과 같이 비교하여도 문제가 되지 않는다. 이는 파이썬에서 음수 인덱싱을 지원하기 때문이다.  
따라서 d[1][0]을 구하는 과정에서 d[1][-1]을 참조하더라도 이는 d[1][m-1]을 참조하는 것과 같다.  

처음에 모든 d의 값이 0 또는 -1로 초기화되었으며 d(x, y)를 구하는 과정이 왼쪽에서 오른쪽으로, 위에서 아래로 순서에 따라 구하기 때문에 
더해지더라도 0을 더해 잘못된 값이 들어가지 않는다. 또한 물 웅덩이의 경우 -1이지만, 이는 ```if d[i-1][j] != -1 또는 if d[i][j-1] != -1``` 조건에 의해 더해지는 연산이 아예 수행되지 않는다.

따라서, 위와 같이 ```i > 0 또는 j > 0``` 조건을 추가하지 않고도 제출답안을 통해 답을 구할 수 있다.
