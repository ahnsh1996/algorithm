# [2021 KAKAO BLIND RECRUITMENT] 매출 하락 최소화
## 문제
### 문제 설명
([원본 문제](https://programmers.co.kr/learn/courses/30/lessons/72416)의 내용을 복사한 것입니다.)

유통전문회사 `카카오상사`의 오너인 `제이지`는 새로운 사업 아이템을 구상하기 위해 전문경영인(CEO)인 `프로도`에게 회사의 경영을 부탁하였습니다.  
"카카오상사"는 직원들을 여러 개의 팀 단위로 조직을 구성하고 있으며 아래 그림은 CEO를 포함하여 10명의 직원과 4개의 팀으로 구성되어 있는 회사 조직도를 보여주고 있습니다.

<img width="500" alt="설명" src="https://user-images.githubusercontent.com/77680436/118932001-86991b00-b982-11eb-83a7-bb0a33269dec.png">

그림의 조직도는 다음과 같이 설명할 수 있습니다.

1. 그림의 각 원들은 각각의 직원 1명을 표시하고 있으며, CEO를 포함하여 총 10명의 직원을 표시하고 있습니다.
2. 원 안에 적힌 두 개의 숫자는 직원의 정보를 담고 있습니다. 왼쪽 숫자는 `직원번호`이며 직원을 식별할 수 있도록 1번부터 순서대로 발급되는 일련번호이며, 오른쪽 숫자는 `해당 직원의 하루평균 매출액`을 나타냅니다. 위 그림에서 `1번` 직원은 14원을, `9번` 직원은 28원의 하루평균 매출액을 기록하고 있습니다.
3. CEO를 포함하여 모든 직원은 팀장 또는 팀원이라는 직위를 가지고 있으며 그림에서는 팀장과 팀원의 관계를 화살표로 표시하고 있습니다. 화살표가 시작되는 쪽의 직원은 팀장, 화살표를 받는 쪽의 직원은 팀원을 의미합니다.  
3-1. 직원번호 `1번`은 회사의 CEO로 고정되어 있으며, CEO는 항상 팀장이고 팀원일 수 없어 화살표를 받는 쪽이 될 수 없습니다.  
3-2. 반면에 CEO를 제외한 나머지 모든 직원들은 다른 누군가로부터 정확히 1개의 화살표를 받게 됩니다.  
3-3. 한 직원은 최대 2개의 팀에 소속될 수 있습니다. 만약 어떤 직원이 두 개의 팀에 소속되어 있다면, 반드시 하나의 팀에서는 팀장, 나머지 팀에서는 팀원이어야 합니다. 팀장을 겸임하거나, 두 개의 팀에서 팀원이 될 수는 없습니다. 예를들어 `10번` 직원은 `D팀`의 팀장이면서 동시에 `5번` 직원이 팀장으로 있는 `C팀`에 속한 팀원입니다.  
3-4. `5번, 9번, 10번` 직원은 받는 쪽의 화살표와 시작하는 화살표가 모두 있으므로 팀장인 동시에 팀원입니다.  
3-5. `2번, 3번, 4번, 6번, 7번, 8번` 직원은 시작하는 화살표가 없고 받는 쪽의 화살표만 있으므로 팀장이 아니며 오직 팀원입니다.  
3-6. `1번` 직원인 CEO는 받는 쪽의 화살표가 없고 시작하는 화살표만 있으며 항상 팀원이 아닌 팀장입니다.  
3-7. 그림의 조직도에는 `A, B, C, D` 총 4개의 팀이 존재하며, 각각 `1번, 9번, 5번, 10번` 직원이 팀장 직위를 담당하게 됩니다.

"제이지"는 자신이 구상한 새로운 사업 아이템에 대해 직원들에게 설명하고자 하루 일정으로 워크숍을 계획하고 있습니다. 단, 모든 직원을 참석시킬 수 없어 아래와 같은 기준으로 워크숍에 참석할 직원들을 선발하려고 합니다.

1. 워크숍에서 교육받은 내용은 전 직원들에게 공유되어야 하므로 `모든 팀은 최소 1명 이상`의 직원을 워크숍에 참석시켜야 합니다.
2. 워크숍 기간 동안, 회사의 매출 손실을 최소화하는 것이 중요하므로 워크숍에 참석하는 직원들의 하루평균 매출액의 합이 최소가 되어야 합니다.

위 그림의 조직도에서 회색으로 색칠된 `1번, 7번, 10번` 직원을 워크숍에 참석시키면 모든 팀에서 최소 한 명 이상의 직원을 참석시킨 것이 되며, 해당 직원들의 하루평균 매출액의 합은 `44(14+13+17)원` 입니다. `10번 직원은 C팀과 D팀 모두에 속해 있으므로, 두 팀에서 모두 참석한 것으로 인정됩니다.`

___

### [문제]
직원들의 하루평균 매출액 값을 담은 배열 sales, 직원들의 `팀장-팀원`의 관계를 나타내는 2차원 배열 links가 매개변수로 주어집니다. 이때, 모든 팀에서 최소 한 명 이상 워크숍에 참석하면서, 참석하는 직원들의 하루평균 매출액의 합을 최소로 하려고 합니다. 그렇게 최소화된 매출액의 합을 구해서 return 하도록 solution 함수를 완성해 주세요.

### [제한사항]
* sales 배열의 크기는 2 이상 300,000 이하입니다. sales 배열의 크기는 CEO를 포함한 전체 직원 수와 같습니다.
  * sales 배열은 각 직원들의 하루평균 매출액을 담고 있으며, `1번` 직원부터 직원번호 순서대로 주어집니다.
  * sales 배열의 각 원소의 값은 0 이상 10,000 이하인 정수입니다.
* links 배열의 크기는 `sales 배열의 크기 - 1` 입니다. 즉, 전체 직원 수보다 1이 작습니다.
* links 배열의 각 원소는 [a, b] 형식입니다.
  * a는 팀장의 직원번호, b는 a팀장이 관리하는 팀원의 직원번호이며, a와 b는 서로 다른 자연수입니다.
  * 1 ≤ `a` ≤ sales 배열의 크기 입니다.
  * 2 ≤ `b` ≤ sales 배열의 크기 입니다.
  * 직원번호 1은 CEO로 정해져 있고 CEO는 항상 팀장으므로 b ≠ 1 입니다.
  * links 배열로 만들어지는 조직도는 하나의 트리 구조 형태입니다.
* 정답으로 return 되는 값은 2<sup>31</sup> - 1 이하인 자연수임이 보장됩니다.

___

### [입출력 예]
|sales|links|result|
|:---|:---|:---|
|[14, 17, 15, 18, 19, 14, 13, 16, 28, 17]|[[10, 8], [1, 9], [9, 7], [5, 4], [1, 5], [5, 10], [10, 6], [1, 3], [10, 2]]|44|
|[5, 6, 5, 3, 4]|[[2,3], [1,4], [2,5], [1,2]]|6|
|[5, 6, 5, 1, 4]|[[2,3], [1,4], [2,5], [1,2]]|5|
|[10, 10, 1, 1]|[[3,2], [4,3], [1,4]]|2|

___

### 입출력 예에 대한 설명
**입출력 예 #1**  
문제 예시와 같습니다.

**입출력 예 #2**  
직원번호가 2인 직원 한 명을 워크숍에 참석시키는 것이 최선이며, 2번 직원의 하루평균 매출액은 6원입니다. 따라서 6을 return 해주어야 합니다.

<img width="500" alt="예시1" src="https://user-images.githubusercontent.com/77680436/118932872-7f264180-b983-11eb-9948-9f9228e60792.png">

**입출력 예 #3**  
직원번호가 4, 5인 직원 두 명을 워크숍에 참석시키는 것이 최선이며, 4번, 5번 직원의 하루평균 매출액의 합은 5(1+4)원 입니다. 따라서 5를 return 해주어야 합니다.

<img width="500" alt="예시2" src="https://user-images.githubusercontent.com/77680436/118932960-9c5b1000-b983-11eb-8b82-8cdcf266c78b.png">

**입출력 예 #4**  
직원번호가 3, 4인 직원 두 명을 워크숍에 참석시키는 것이 최선이며, 3번, 4번 직원의 하루평균 매출액의 합은 2(1+1)원 입니다. 따라서 2를 return 해주어야 합니다.

<img width="500" alt="예시3" src="https://user-images.githubusercontent.com/77680436/118933037-b3016700-b983-11eb-98df-97366222939b.png">

## 제출답안
```python
def getMinSale(team, leader, sales, minSale): # leader 팀이 루트인 서브 트리의 최적해를 구함
    if leader in minSale: return minSale[leader] # 이미 구한 적이 있는 해라면 저장된 값 반환
    
    subTeam = [mem for mem in team[leader][1:] if mem in team] # 현재 팀의 하위 팀을 구함
    teamMin = min(map(lambda x: sales[x-1], team[leader])) # 팀 내에서 최소인 매출을 구함
    if not subTeam: # 단말 노드라면, 즉 하위 팀이 없다면 팀 내의 최소 매출 반환
        minSale[leader] = teamMin
        return teamMin
    else: # 하위 팀이 존재한다면
        subSum = sum(getMinSale(team, sub, sales, minSale) for sub in subTeam) # 하위 팀을 루트로 하는 최적해를 모두 더함
        min_sale = subSum + teamMin # 하위 팀과 연결에 상관없이(하위 팀의 팀장인 멤버를 고르는 것과 상관없이) 최소 매출인 멤버를 참여시키는 경우
        for sub in subTeam: # 하위 팀의 팀장인 멤버를 고르는 경우
            sale = subSum - getMinSale(team, sub, sales, minSale)
            subsubTeam = [mem for mem in team[sub][1:] if mem in team]
            sale += sum(getMinSale(team, subsub, sales, minSale) for subsub in subsubTeam) + sales[sub-1]
            if min_sale > sale: min_sale = sale # 가장 이득이 되는 경우를 고름
                
        minSale[leader] = min_sale
        return min_sale

def solution(sales, links):
    team = dict() # 팀원 정보 저장
    minSale = dict() # 특정 노드가 루트인 서브 트리의 최적해를 저장

    for leader, member in links:
        if leader in team: team[leader].append(member)
        else: team[leader] = [leader, member]
            
    return getMinSale(team, 1, sales, minSale) # 1번 노드(CEO)가 루트인 트리, 즉 전체의 최적해를 구함
```
### 설명
본 문제의 경우 다이나믹 프로그래밍 문제이다. 프로그래머스에 공개된 카카오 문제 중에서 파이썬을 지원하지 않는 2017년 문제를 제외하고 모든 문제를 풀어보았는데, 그 중 유일한 DP 문제인 것 같다.

사실 다이나믹 프로그래밍은 개인적으로 많이 어렵다고 느껴서 맨날 미루면서 잘 풀어보지 않았는데, 그래서 그런지 풀어본 카카오 문제 중에서는 가장 어려웠던 것 같다.  
(~~사실 나뿐만 아니라 프로그래머스의 카카오 문제 중에서 2017년 문제를 제외하고 푼 사람이 가장 적은 문제기는 하다.~~)

각설하고 풀이에 대해서 이야기 하자면 본 풀이는 카카오 공식 풀이와는 다르게 풀었으므로 카카오 공식 풀이가 궁금한 사람은 [이곳](https://tech.kakao.com/2021/01/25/2021-kakao-recruitment-round-1/)을 
참고하길 바란다.

문제를 유심히 살펴보면 각 팀에서 워크숍에 참가할 가능성이 있는 멤버는 두 종류이다. `팀장`이거나 `매출액이 최소인 팀원`인 경우에만 워크숍에 참가할 가능성이 있다.

따라서 우리는 두 가지 경우만 고려해주면 된다.

먼저 다이나믹 프로그래밍을 이용하기 위해서 부분 문제를 해를 가지고 있는 다이나믹 배열을 다음과 같이 정의하였다.  
`minSale[leader] = leader 팀이 루트인 서브 트리의 최적해`

그러므로 문제에서 요구하고 있는 것은 전체 트리의 루트인 1번 노드의 최적해 `minSale[1]`을 구하고자 하는 것이다.

이제 `minSale[leader]`를 구하는 점화식을 생각해보자.
```
teamMin = leader 팀 내에서 최소 매출액
sub = leader 팀의 하위 팀
subsub = sub 팀의 하위 팀

1) leader 팀이 단말 노드인 경우(하위 팀이 없는 경우)
   minSale[leader] = teamMin
   
2) leader 팀이 단말 노드가 아닌 경우(하위 팀이 존재하는 경우)
   minSale[leader] = min(sum(minSale[sub])+teamMin, min(sum(minSale[sub])-minSale[sub]+sum(minSale[subsub])+sales[subLeader]))
```

위와 같이 식을 세울 수 있다.

가장 간단한 경우부터 생각해보자. 어떤 팀이 하위 팀이 존재하지 않는 트리의 단말 노드라면 해당 팀의 최적해를 구하는 것은 쉽다. 해당 팀만을 고려하면 되기 때문에 팀 내에서 최소가 되는 
매출액을 고르면 된다.

이번에는 단말 노드가 아닌 경우를 생각해보자. 단말 노드가 아닌 경우에는 다시 두 가지로 나뉜다.

1. 팀 내에서 매출액이 최소인 팀원을 참석시키는 경우
2. 다른 하위 팀의 팀장을 맡고 있는 팀원을 참석시키는 경우

1번의 경우 어렵지 않다. 하위 팀의 경우 이미 최적해를 구했기 때문에(하위 팀에서는 적어도 1명 참가하기 때문에) 하위 팀의 최적해의 합에 현재 팀원 한 명을 추가해주기만 하면 된다.  
즉, `sum(minSale[sub])+teamMin`이 된다. 1번과 2번이 겹치는 경우, 다시 말해 팀 내에서 매출액이 최소인 팀원이 하위 팀의 팀장인 경우에는 `sum(minSale[sub])+teamMin`로 처리하면 안 되지만 
이는 어차피 2번이 최소인 경우를 계산할 때 처리된다.

이제 2번의 경우이다. 사실 2번이 본 문제의 핵심이라고 할 수 있다.

<img width="500" alt="설명" src="https://user-images.githubusercontent.com/77680436/118932001-86991b00-b982-11eb-83a7-bb0a33269dec.png">

위에서 `A`팀의 최적해를 구하는 과정을 생각해보자. 이때 `A`팀에서는 `5번` 팀원이 워크숍에 참가하는 경우의 매출액 합을 구하려고 한다. 
`A`팀을 제외한 최적해의 경우 `B`팀에서 `7번`, `C, D`팀에서 `10번` 팀원이 회의를 참가하는 것으로 구해져있다. 이 상태에서 `A`팀이 `5번` 팀원을 참석시키면 어떻게 될까.  
`A`팀에선 `5번`, `B`팀에서 `7번`, `C`팀에선 `5번, 10번`, 그리고 `D`팀에서 `10번`이 참가하게 된다. 따라서 `C`팀에서는 불필요하게 두 명이 참가하게 된다.

그렇기 때문에 `A`팀이 `5번`을 고름에 따라 `C`팀에서는 기존의 `10번`을 취소하여야 하며 `D`팀 역시 `10번` 보다 최적인 `6번`이 참가하는 경우로 수정되어야 한다.  
이는  
1. `A`팀을 제외한 최적해(`B, C, D` 참가)에서 → `sum(minSale[A의 sub])`
2. `C` 팀을 선택하기 전으로 돌아가고 → `sum(minSale[A의 sub])` - `minSale[C]+sum(minSale[C의 sub])`
3. `C`팀의 팀장을 선택하는 것이다. → `sum(minSale[A의 sub])-minSale[C]+sum(minSale[C의 sub])` + `sales[C]`

따라서 2번의 경우 단순히 최소인 팀원을 추가하는 `sum(minSale[sub])+teamMin`과 팀장인 멤버가 참가하는 `sum(minSale[sub])-minSale[sub]+sum(minSale[subsub])+sales[subLeader]` 경우들 
중에서 최소를 고르면 된다.  
(`min(sum(minSale[sub])+teamMin, min(sum(minSale[sub])-minSale[sub]+sum(minSale[subsub])+sales[subLeader]))`)

이때 하위 팀의 최적해나 하위 팀의 하위 팀 최적해를 구하는 부분 문제가 반복되기 때문에 이는 DP의 핵심인 메모이제이션을 통해 해결한다.

위의 내용을 종합하여 코딩으로 구현한 것이 제출답안과 같다.
