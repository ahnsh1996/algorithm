# [프로그래머스] 가장 먼 노드
## 문제
### 문제 설명
([원본 문제](https://programmers.co.kr/learn/courses/30/lessons/49189)의 내용을 복사한 것입니다.)

n개의 노드가 있는 그래프가 있습니다. 각 노드는 1부터 n까지 번호가 적혀있습니다. 1번 노드에서 가장 멀리 떨어진 노드의 갯수를 구하려고 합니다. 가장 멀리 떨어진 노드란 최단경로로 이동했을 때 간선의 개수가 가장 많은 노드들을 의미합니다.

노드의 개수 n, 간선에 대한 정보가 담긴 2차원 배열 vertex가 매개변수로 주어질 때, 1번 노드로부터 가장 멀리 떨어진 노드가 몇 개인지를 return 하도록 solution 함수를 작성해주세요.

### 제한사항
* 노드의 개수 n은 2 이상 20,000 이하입니다.
* 간선은 양방향이며 총 1개 이상 50,000개 이하의 간선이 있습니다.
* vertex 배열 각 행 [a, b]는 a번 노드와 b번 노드 사이에 간선이 있다는 의미입니다.

### 입출력 예
|n|vertex|return|
|:---|:---|:---|
|6|[[3, 6], [4, 3], [3, 2], [1, 3], [1, 2], [2, 4], [5, 2]]|3|

### 입출력 예 설명
예제의 그래프를 표현하면 아래 그림과 같고, 1번 노드에서 가장 멀리 떨어진 노드는 4,5,6번 노드입니다.

![문제 예시](https://user-images.githubusercontent.com/77680436/107747341-9f2ddf80-6d5a-11eb-9dc3-8fee18ed87fe.png)

## 제출답안
```python
from collections import deque
def bfs(adj, start, visited): # 너비 우선 탐색 겸 출발지로부터 거리 저장
    queue = deque([start])
    while queue:
        v = queue.popleft()
        for i in adj[v]: # 현재 노드에서 인접한 노드 중에서
            if i is not start and not visited[i]: # 출발지가 아니고 아직 방문하지 않았다면
                queue.append(i) # 방문
                visited[i] = visited[v] + 1 # 방문 표시를 남김(+ 거리를 나타내는 역할도 수행)

def solution(n, edge):
    adj = [[] for _ in range(n)]
    visited = [0]*n # visited는 방문했는지 여부 겸 출발지로부터의 거리를 나타냄
    
    for i, j in edge: # 그래프를 인접 리스트로 저장
        adj[i-1].append(j-1)
        adj[j-1].append(i-1)
        
    bfs(adj, 0, visited) # 그래프를 1번 노드부터 너비 우선 탐색을 실시함
        
    return visited.count(max(visited)) # 출발지로부터 거리가 최대인 노드의 개수를 반환
```
### 설명
본 문제는 BFS를 이용한다면 간단히 풀어낼 수 있는 문제이다. 먼저 BFS, 즉 너비 우선 탐색은 시작 정점에서부터 현재 깊이에서 인접한 정점들을 우선 방문하는 방법이다.  
BFS를 구현하기 위해서 보통 큐를 이용한다. 큐에는 방문한 노드가 들어가는데, 출발지부터 큐에 담아 제일 먼저 방문한다. 이후 큐에서 방문한 노드를 꺼내어 해당 노드에서 인접한 노드들 중 
방문하지 않은 노드들을 방문한다.(큐에 넣고 방문 했음을 기록한다) 이처럼 인접한 노드들을 큐에 놓고 꺼내는 과정을 반복하면 너비 우선 탐색을 수행할 수 있는데, 이를 그림을 통해 나타내면 
다음과 같다.(예시 그림을 1번 노드부터 BFS를 수행했을 경우)

<div align="center">
<img width="90%" alt="BFS 예시" src="https://user-images.githubusercontent.com/77680436/107753502-8118ad00-6d63-11eb-96fb-c2f025ea18a7.gif"></br>
(인접한 노드 중 어떤 노드를 먼저 방문하는지는 구현에 따라 다르며, 위의 예시는 숫자가 작은 노드를 먼저 방문 하였다.)</div></p>


보통 방문 여부의 경우 True/False 값을 이용해서 나타내주는데, 여기서는 T/F 값 대신 출발지로부터의 거리를 넣어주는 것으로 대체한다. T/F 대신 출발지로부터 거리를 넣더라도 대부분의 
언어에서는 0을 제외한 수는 True를 의미하기 때문에 원래의 기능 역시 수행할 수 있다. 거리를 넣을 때는 현재 노드에서 인접한 노드를 방문할 때, 현재 노드의 거리 + 1을 하여 값을 넣어준다. 
이때 출발지의 경우는 규칙에 예외가 발생하기 때문에 ```is not start``` 조건을 통해 출발지가 아닐 경우라는 조건을 추가하였다.

따라서 위의 경우 visited 리스트의 최종 결과는 ```[0, 1, 1, 2, 2, 2]```가 되며, 이 중 최댓값인 2의 개수를 세어 반환하면 1번 노드에서 가장 멀리 떨어진 노드의 개수를 구할 수 있다.
