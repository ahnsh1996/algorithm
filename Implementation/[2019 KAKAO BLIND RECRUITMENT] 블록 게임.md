# [2019 KAKAO BLIND RECRUITMENT] 블록 게임
## 문제
### 문제 설명
([원본 문제](https://programmers.co.kr/learn/courses/30/lessons/42894)의 내용을 복사한 것입니다.)

### 블록게임

프렌즈 블록이라는 신규 게임이 출시되었고, 어마어마한 상금이 걸린 이벤트 대회가 개최 되었다.

이 대회는 사람을 대신해서 플레이할 프로그램으로 참가해도 된다는 규정이 있어서, 게임 실력이 형편없는 프로도는 프로그램을 만들어서 참가하기로 결심하고 개발을 시작하였다.

프로도가 우승할 수 있도록 도와서 빠르고 정확한 프로그램을 작성해 보자.

**게임규칙**

아래 그림과 같이 1×1 크기의 블록을 이어 붙여 만든 3 종류의 블록을 회전해서 총 12가지 모양의 블록을 만들 수 있다.

![블록모양](https://user-images.githubusercontent.com/77680436/118446931-22304e80-b72b-11eb-9cb4-63f7a646308f.png)

1 x 1 크기의 정사각형으로 이루어진 N x N 크기의 보드 위에 이 블록들이 배치된 채로 게임이 시작된다. (보드 위에 놓인 블록은 회전할 수 없다). 모든 블록은 블록을 구성하는 사각형들이 정확히 보드 위의 사각형에 맞도록 놓여있으며, 선 위에 걸치거나 보드를 벗어나게 놓여있는 경우는 없다.

플레이어는 위쪽에서 1 x 1 크기의 검은 블록을 떨어뜨려 쌓을 수 있다. 검은 블록은 항상 맵의 한 칸에 꽉 차게 떨어뜨려야 하며, 줄에 걸치면 안된다.  
이때, 검은 블록과 기존에 놓인 블록을 합해 <b><ins>속이 꽉 채워진</ins></b> 직사각형을 만들 수 있다면 그 블록을 없앨 수 있다.

예를 들어 검은 블록을 떨어뜨려 아래와 같이 만들 경우 주황색 블록을 없앨 수 있다.

![예시1](https://user-images.githubusercontent.com/77680436/118447078-5146c000-b72b-11eb-91e1-eb7b7a404ece.png)

빨간 블록을 가로막던 주황색 블록이 없어졌으므로 다음과 같이 빨간 블록도 없앨 수 있다.

![예시2](https://user-images.githubusercontent.com/77680436/118447123-5c99eb80-b72b-11eb-9bf1-2886f5ae85b2.png)

그러나 다른 블록들은 검은 블록을 떨어뜨려 직사각형으로 만들 수 없기 때문에 없앨 수 없다.

따라서 위 예시에서 없앨 수 있는 블록은 최대 2개이다.

보드 위에 놓인 블록의 상태가 담긴 2차원 배열 board가 주어질 때, 검은 블록을 떨어뜨려 없앨 수 있는 블록 개수의 최댓값을 구하라.

### 제한사항
* board는 블록의 상태가 들어있는 N x N 크기 2차원 배열이다.
  * N은 `4` 이상 `50` 이하다.
* board의 각 행의 원소는 `0` 이상 `200` 이하의 자연수이다.
  * 0 은 빈 칸을 나타낸다.
  * board에 놓여있는 각 블록은 숫자를 이용해 표현한다.
  * 잘못된 블록 모양이 주어지는 경우는 없다.
  * 모양에 관계 없이 서로 다른 블록은 서로 다른 숫자로 표현된다.
  * 예를 들어 문제에 주어진 예시의 경우 다음과 같이 주어진다.

![예시3](https://user-images.githubusercontent.com/77680436/118447242-818e5e80-b72b-11eb-89a5-43e3d4daa7f1.png)

___

### 입출력 예
|board|result|
|:---|:---|
|[[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,4,0,0,0],[0,0,0,0,0,4,4,0,0,0],[0,0,0,0,3,0,4,0,0,0],[0,0,0,2,3,0,0,0,5,5],[1,2,2,2,3,3,0,0,0,5],[1,1,1,0,0,0,0,0,0,5]]|2|

### 입출력 예 설명
입출력 예 #1  
문제에 주어진 예시와 같음

## 제출답안
```python
def rangeCheck(x, y, n):
    return x >= 0 and x < n and y >= 0 and y < n

def check(x1, x2, y, dx, board): # 검은 블록의 모양에 따라 제거 가능한 블록 모양인지 판단
    if board[y][x1] == board[y][x2]:
        if dx == 1:
            if rangeCheck(x1-1, y-1, len(board)) and board[y][x1] == board[y-1][x1-1]: # 1-3번
                return True
            if rangeCheck(x2+1, y-1, len(board)) and board[y][x1] == board[y-1][x2+1]: # 2-3번
                return True
        elif dx == 2:
            if rangeCheck(x1+1, y-1, len(board)) and board[y][x1] == board[y-1][x1+1]: # 3-1번
                return True
        else: # dx == 0
            if rangeCheck(x1-1, y-2, len(board)) and board[y][x1] == board[y-2][x1-1]: # 2-2번
                return True
            if rangeCheck(x1+1, y-2, len(board)) and board[y][x1] == board[y-2][x1+1]: # 1-4번
                return True
    return False

def solution(board):
    answer = 0
    n = len(board)

    while True:
        blocks = set()
        for dx in (1, 2, 0):
            for x1 in range(n-dx): # 첫 번째 블록의 x 좌표
                x2 = x1 + dx # 함께 떨어질 두 번째 블록의 x좌표
                for y in range(n):
                    if board[y][x1] or board[y][x2]: # 둘 중 하나라도 블록에 닿았을 때
                        if check(x1, x2, y, dx, board): # 제거될 수 있는 5개의 모양 중에 하나면서 상단에 다른 블록이 없을 때
                            blocks.add(board[y][x1]) # 제거할 블록에 추가
                        break

        if not blocks: break # 더 이상 제거할 블록이 없다면 종료

        for x in range(n): # 블록 제거
            for y in range(n):
                if board[y][x] in blocks: board[y][x] = 0

        answer += len(blocks)

    return answer
```
### 설명
본 문제는 규칙에 따라 블록을 제거하는 시뮬레이션 프로그램을 구현하는 문제이다.

먼저 블록이 제거될 수 있는 경우를 살펴보자. 문제 설명을 보면 블록은 다음과 같이 12가지 모양이 존재한다.

![블록모양](https://user-images.githubusercontent.com/77680436/118446931-22304e80-b72b-11eb-9cb4-63f7a646308f.png)

하지만 검은색 블록은 상단에서 떨어지는 것만이 유일한 움직임이기 때문에 사실상 제거될 수 있는 모양은 다음과 같이 5가지로 한정되어 있다.

![제거가능블록](https://user-images.githubusercontent.com/77680436/118451262-07140d80-b730-11eb-9dfb-fd6828327ab3.png)

그렇다면 블록이 제거되는 경우는 위의 5가지 블록 모양이면서 검은색 블록이 와야하는 빈칸 위로는 다른 블록이 방해하지 않는 경우가 될 것이다.

이를 판단하기 위해서 본 답안에서는 블록을 두 개씩 떨어뜨리는 방법을 사용하였다.

위의 모양을 살펴보면 검은색 블록이 하나의 블록을 지우기 위해 만들어지는 모양은 총 3가지로 한정되어 있다.

먼저 1-3번과 2-3번의 블록을 없애는 경우에는 검은색 블록이 다음과 같은 모양이 된다.

![검은블록모양1](https://user-images.githubusercontent.com/77680436/118456515-48a6b780-b734-11eb-9536-125b19129255.png)

다음으로 3-1번의 블록을 없애는 경우에는 검은색 블록이 다음과 같은 모양이 된다.

![검은블록모양2](https://user-images.githubusercontent.com/77680436/118456674-52301f80-b734-11eb-8a2f-83b0350abd61.png)

마지막으로 1-4번과 2-2번의 블록을 없애는 경우는 검은색 블록이 다음과 같은 모양이 된다.

![검은블록모양3](https://user-images.githubusercontent.com/77680436/118457040-67a54980-b734-11eb-88bc-444db13e9255.png)

이처럼 두 검은 블록의 x 좌표는 1, 2, 0 만큼 차이가 나는 것을 확인할 수 있다.

따라서 시뮬레이션을 위해 검은 블록을 떨어뜨려볼 때 첫 번째 블록 `(x, y)`를 기준으로 각각 `(x+1, y)`, `(x+2, y)`, `(x, y-1)` 의 좌표를 갖는 두 번째 검은 블록 동시에 떨어뜨려 보는 방법을 사용할 것이다.  
이런 식으로 말이다.

<img width="420" alt="검은블록예시" src="https://user-images.githubusercontent.com/77680436/118465548-f322d880-b73c-11eb-82a2-3cfbd2668ced.gif">  
(마지막 모양의 경우 하나의 블록만 상단에 다른 블록이 없는지 확인하면 다른 블록도 확인되므로 실제로는 하나의 블록만 떨어뜨림)

이렇게 두 개의 검은 블록이 떨어졌을 때, 두 블록이 같은 블록 위에 떨어졌으면서 검은 블록의 모양에 따라 제거될 수 있는 블록 모양에 매칭되면 블록을 제거할 수 있다고 판단할 수 있다.

이에 따라 각 모양에 맞는 블록이 맞는지 확인하는 함수를 구현하고 검은 블록을 떨어뜨리며 확인한다면 나머지 구현은 어렵지 않다.

이러한 과정을 더 이상 제거할 블록이 없을 때까지 반복하면서 블록을 제거하고 제거된 블록을 세어주면 정답을 도출할 수 있다.
