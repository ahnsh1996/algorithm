# [프로그래머스] 입국심사
## 문제
### 문제 설명
([원본 문제](https://programmers.co.kr/learn/courses/30/lessons/43238)의 내용을 복사한 것입니다.)

n명이 입국심사를 위해 줄을 서서 기다리고 있습니다. 각 입국심사대에 있는 심사관마다 심사하는데 걸리는 시간은 다릅니다.

처음에 모든 심사대는 비어있습니다. 한 심사대에서는 동시에 한 명만 심사를 할 수 있습니다. 가장 앞에 서 있는 사람은 비어 있는 심사대로 가서 심사를 받을 수 있습니다. 하지만 더 빨리 끝나는 심사대가 있으면 기다렸다가 그곳으로 가서 심사를 받을 수도 있습니다.

모든 사람이 심사를 받는데 걸리는 시간을 최소로 하고 싶습니다.

입국심사를 기다리는 사람 수 n, 각 심사관이 한 명을 심사하는데 걸리는 시간이 담긴 배열 times가 매개변수로 주어질 때, 모든 사람이 심사를 받는데 걸리는 시간의 최솟값을 return 하도록 solution 함수를 작성해주세요.

### 제한사항
* 입국심사를 기다리는 사람은 1명 이상 1,000,000,000명 이하입니다.
* 각 심사관이 한 명을 심사하는데 걸리는 시간은 1분 이상 1,000,000,000분 이하입니다.
* 심사관은 1명 이상 100,000명 이하입니다.

### 입출력 예
|n|times|return|
|:---|:---|:---|
|6|[7, 10]|28|

### 입출력 예 설명
가장 첫 두 사람은 바로 심사를 받으러 갑니다.

7분이 되었을 때, 첫 번째 심사대가 비고 3번째 사람이 심사를 받습니다.

10분이 되었을 때, 두 번째 심사대가 비고 4번째 사람이 심사를 받습니다.

14분이 되었을 때, 첫 번째 심사대가 비고 5번째 사람이 심사를 받습니다.

20분이 되었을 때, 두 번째 심사대가 비지만 6번째 사람이 그곳에서 심사를 받지 않고 1분을 더 기다린 후에 첫 번째 심사대에서 심사를 받으면 28분에 모든 사람의 심사가 끝납니다.

## 제출답안
```python
def solution(n, times):
    answer = low = 0
    high = max(times)*(n//len(times)) # 이진 탐색 범위 설정

    while low <= high:
        mid = (low+high) // 2 # 심사를 받는데 걸리는 시간을 mid 분이라고 가정
        if sum(map(lambda x: mid//x, times)) >= n: # 모든 사람이 mid 분 내에 검사를 받을 수 있으면
            high = mid - 1 # 더 최솟값이 존재하는지 탐색
            answer = mid # 현재 값 저장
        else:
            low = mid + 1 # 검사를 받을 수 없으면 받을 수 있도록 시간을 증가
    
    return answer
```
### 설명
본 문제는 일반적으로 이진 탐색을 응용하는 파라메트릭 서치(Parametric search)를 이용하여 해결할 수 있다. 그렇다면 파라메트릭 서치는 무엇일까. 파라메트릭 서치는 
```최적화 문제를 결정 문제로 바꾸어 푸는 기법```을 말한다.

아직은 이러한 내용이 잘 와닿지 않을 수 있다. 이를 이해하기 위해서 먼저 이진 탐색을 살펴보자. 예를 들어서 1부터 10까지 정렬되어 있는 리스트에서 6이라는 값을 찾는다면 이진 탐색은 다음과 
같은 과정을 거친다.

<1>  
```[1(low)    2    3    4    5(mid)    6    7    8    9    10(high)]```  
이진탐색: mid(5)! 너 7이야?  
mid: 난 7이 아니야, 7보다 작아.  
이진탐색: 그래? 그럼 너의 오른쪽 부분을 탐색해야겠다.

<2>  
```[1    2    3    4    5    6(low)    7    8(mid)    9    10(high)]```  
이진탐색: mid(8)! 너 7이야?  
mid: 난 7이 아니야, 7보다 커.  
이진탐색: 그래? 그럼 너의 왼쪽 부분을 탐색해야겠다.

<3>  
```[1    2    3    4    5    6(low)(mid)    7(high)    8    9    10]```  
이진탐색: mid(6)! 너 7이야?  
mid: 난 6이 아니야, 7보다 작아.  
이진탐색: 그래? 그럼 너의 오른쪽 부분을 탐색해야겠다.

<4>  
```[1    2    3    4    5    6    7(low)(mid)(high)    8    9    10]```  
이진탐색: mid(7)! 너 7이야?  
mid: 맞아, 내가 7이야.  
이진탐색: 찾았다!

위와 같이 이진 탐색에서는 매 단계마다 mid가 7인지 질문하고 mid는 7인지 아닌지 대답한다. 조금 더 프로그래밍적으로 보자면 ```mid == 7```의 조건을 만족하는지 확인해가며 7이 맞을 때까지 
범위를 달리 해가며 이를 찾아나간다.

이진 탐색과 같이 파라메트릭 서치에서도 비슷한 과정을 거친다. 즉 특정 조건을 만족하는지, 만족하지 않는지 **결정**(예/아니요)해가며, 만족하는 것들 중 최적을 찾아내는 과정을 거친다.

한 가지 예를 들어 아래와 같은 리스트가 있을 때, 6 이상의 수 중 가장 작은 값을 찾는다면 다음과 같은 과정을 거친다.

<1>  
```[1(low)    3    4    5(mid)    6    8    10(high)]```  
PS: mid(5)! 너 6보다 크거나 같아?  
mid: 아니, 난 6보다 작아.  
PS: 그래? 그럼 너의 오른쪽 부분을 탐색해야겠다.

<2>  
```[1    3    4    5    6(low)    8(mid)    10(high)]```  
PS: mid(8)! 너 6보다 크거나 같아?  
mid: 맞아, 난 6보다 크거나 같아.  
PS: 좋아! 일단 널 후보로 두고 더 작은 값이 있는지 너의 왼쪽 부분을 탐색해야겠다.

<3>  
```[1    3    4    5    6(low)(mid)(high)    8    10]```  
PS: mid(6)! 너 6보다 크거나 같아?  
mid: 맞아, 난 6보다 크거나 같아.  
PS: 좋아! 일단 널 후보로 두고 더 작은 값이 있는지 너의 왼쪽 부분을 탐색해야겠다.

<4>  
PS: 이제 더 찾을 곳이 없네? 6! 니가 6이상의 수 중에 가장 작은 값이야!

파라메트릭 서치의 과정을 살펴보면 이진 탐색과 상당히 유사하다는 것을 알 수 있다. 즉, mid가 6보다 크거나 같은지(mid >= 6), 그렇지 않은지를 확인해가며 범위를 조정해서 최솟값을 찾았다. 이처럼 
파라메트릭 서치는 본 문제와 같이 최솟값을 찾거나 하는 등의 최적화 문제를 단순히 특정 조건을 만족하는지, 만족하지 않는지의 결정 과정의 반복으로 풀어낼 수 있다는 큰 장점을 가지고 있다.

그렇다면 본 문제를 파라메트릭 서치를 이용하기 위해서 어떻게 조건을 세울 수 있을까. 조건을 간단히 생각하면 심사관들에게 이렇게 질문해볼 수 있다.  
"심사관들! x분을 주면 너네 여기 있는 사람들 다 심사할 수 있어?"  
이처럼 x분 동안 심사관들이 모든 사람을 심사할 수 있는지 아닌지 결정해가며 그 중 가장 작은 값을 찾아낸다면, 본 문제를 해결할 수 있다.

예를 들어서 25분이 주어졌다고 하자. 25분동안 예제와 같은 조건이라면 심사관들은 6명을 전부 심사할 수 있을까? 먼저 첫 번째 심사관은 심사를 하는데 7분이 소요된다. 따라서 25분동안 최대 3명(25/7)을 
심사할 수 있다. 두 번째 심사관은 심사를 하는데 10분이 소요된다. 따라서 25분동안 최대 2명(25/10)을 심사할 수 있다. 따라서 첫 번째 심사관과 두 번째 심사관을 합하여도 최대 5명밖에 심사할 수 
없으므로, 6명을 심사할 수 있는지에 대한 질문에는 '아니요.'의 결과를 얻게된다.

이같은 **주어진 x분 동안 모든 사람을 심사할 수 있는지**에 대한 조건을 파이썬을 통해 나타나면 ```sum(map(lambda x: mid//x, times)) >= n```로 나타낼 수 있다. 따라서 본 문제에서는 범위를 
설정하고 범위를 조정해가면서 이러한 조건을 만족하는지 결정을 반복하여 의도했던 최소 시간을 구할 수 있다.

여기서 처음의 범위를 얼마나 가능한 작게 설정하느냐에 따라서 알고리즘을 조금 더 최적화할 수 있다. 예를 들어 아무렇게나 큰 수를 high로 설정한다면 이는 경우에 따라서 부정확하거나 
원하는 결과를 얻기 위해서 더 불필요한 부분을 탐색하게 될 수 있다. 따라서 처음의 범위를 잘 설정하여야 하는데, 이는 개인의 역량에 따라 어느 정도 차이가 날 것이라고 생각한다. 본 문제에서는 
최적의 범위는 아닐 수 있지만, 쉽게 생각할 수 있는 최대 범위는 심사관마다 동일한 인원을 심사한다고 했을 때, 가장 오래 걸리는 심사관을 기준으로 high를 정할 수 있다. 예를 들어 예시의 조건이라고 했을 때, 
심사관은 두 명이므로 3명씩 맡아 심사를 할 수 있다. 이때, 가장 오래 걸리는 심사관은 10분이기 때문에 30분(10*3)을 초기 high로 설정할 수 있을 것이다.

종합하여 예시 과정을 제출 답안을 통해 풀이하는 과정은 다음과 같다.

|순서|low|high|mid|최대로 심사할 수 있는 인원|조건 만족 여부|현재 최소 시간|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|1|0분|30분|15분|3명|False||
|2|16분|30분|23분|5명|False||
|3|24분|30분|27분|5명|False||
|4|28분|30분|29분|6명|True|29분|
|5|28분|28분|28분|6명|True|28분|
