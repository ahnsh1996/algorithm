# [2019 카카오 개발자 겨울 인턴십] 징검다리 건너기
## 문제
### 문제 설명
([원본 문제](https://programmers.co.kr/learn/courses/30/lessons/64062)의 내용을 복사한 것입니다.)

카카오 초등학교의 "니니즈 친구들"이 "라이언" 선생님과 함께 가을 소풍을 가는 중에 <b>징검다리</b>가 있는 개울을 만나서 건너편으로 건너려고 합니다. "라이언" 선생님은 "니니즈 친구들"이 무사히 징검다리를 건널 수 있도록 다음과 같이 규칙을 만들었습니다.

* 징검다리는 일렬로 놓여 있고 각 징검다리의 디딤돌에는 모두 숫자가 적혀 있으며 디딤돌의 숫자는 한 번 밟을 때마다 1씩 줄어듭니다.
* 디딤돌의 숫자가 0이 되면 더 이상 밟을 수 없으며 이때는 그 다음 디딤돌로 한번에 여러 칸을 건너 뛸 수 있습니다.
* 단, 다음으로 밟을 수 있는 디딤돌이 여러 개인 경우 무조건 가장 가까운 디딤돌로만 건너뛸 수 있습니다.

"니니즈 친구들"은 개울의 왼쪽에 있으며, 개울의 오른쪽 건너편에 도착해야 징검다리를 건넌 것으로 인정합니다.  
"니니즈 친구들"은 한 번에 한 명씩 징검다리를 건너야 하며, 한 친구가 징검다리를 모두 건넌 후에 그 다음 친구가 건너기 시작합니다.

디딤돌에 적힌 숫자가 순서대로 담긴 배열 stones와 한 번에 건너뛸 수 있는 디딤돌의 최대 칸수 k가 매개변수로 주어질 때, 최대 몇 명까지 징검다리를 건널 수 있는지 return 하도록 solution 함수를 완성해주세요.

### 제한사항
* 징검다리를 건너야 하는 니니즈 친구들의 수는 무제한 이라고 간주합니다.
* stones 배열의 크기는 1 이상 200,000 이하입니다.
* stones 배열 각 원소들의 값은 1 이상 200,000,000 이하인 자연수입니다.
* k는 1 이상 stones의 길이 이하인 자연수입니다.

___

### 입출력 예
|stones|k|result|
|:---|:---|:---|
|[2, 4, 5, 3, 2, 1, 4, 2, 5, 1]|3|3|

### 입출력 예에 대한 설명
**입출력 예 #1**

첫 번째 친구는 다음과 같이 징검다리를 건널 수 있습니다.

![예시1](https://user-images.githubusercontent.com/77680436/117648037-b00ab780-b1c8-11eb-8fce-2bfdba376b80.png)

첫 번째 친구가 징검다리를 건넌 후 디딤돌에 적힌 숫자는 아래 그림과 같습니다.  
두 번째 친구도 아래 그림과 같이 징검다리를 건널 수 있습니다.

![예시2](https://user-images.githubusercontent.com/77680436/117648086-c44eb480-b1c8-11eb-85cd-d27e09141b2b.png)

두 번째 친구가 징검다리를 건넌 후 디딤돌에 적힌 숫자는 아래 그림과 같습니다.  
세 번째 친구도 아래 그림과 같이 징검다리를 건널 수 있습니다.

![예시3](https://user-images.githubusercontent.com/77680436/117648134-d16ba380-b1c8-11eb-8eb2-78beed673c2d.png)

세 번째 친구가 징검다리를 건넌 후 디딤돌에 적힌 숫자는 아래 그림과 같습니다.  
네 번째 친구가 징검다리를 건너려면, 세 번째 디딤돌에서 일곱 번째 디딤돌로 네 칸을 건너뛰어야 합니다. 하지만 k = 3 이므로 건너뛸 수 없습니다.

![예시4](https://user-images.githubusercontent.com/77680436/117648179-dfb9bf80-b1c8-11eb-8410-4b73a9c5ecb3.png)

따라서 최대 3명이 디딤돌을 모두 건널 수 있습니다.

## 제출답안
```python
def check(stones, num, k): # num 미만인 돌이 k개 연속으로 있는지 체크, 즉 num명이 건널 수 있는지 체크
    chk = 0
    for stone in stones:
        chk = chk+1 if stone < num else 0
        if chk == k: return False
    return True

def solution(stones, k):
    answer = 0
    low = min(stones)
    high = max(stones)
    
    while low <= high: # 이분 탐색(파라메트릭 서치)을 진행하며 건널 수 있는 최댓값을 구함
        mid = (low + high) // 2
        if check(stones, mid, k): # 건널 수 있다면
            low = mid + 1 # 더 큰 값이 가능한지 탐색
            answer = mid # 정답 후보로 저장
        else: high = mid - 1

    return answer
```
### 설명
본 문제의 경우 직접 인원을 늘려가면 시뮬레이션을 통해 풀 수도 있겠지만, 이 경우 효율성 검증을 통과할 수 없을 것이다.

따라서 효율적인 풀이를 위해 다양한 방법을 생각해볼 수 있는데, 문제에서 최대로 건널 수 있는 인원을 임의로 설정 했을 때 설정된 인원만큼 무사히 건널 수 있는지 확인할 수 있는 조건이 
명백하여 본 풀이에서는 파라메트릭 서치(이분 탐색)을 이용하여 문제를 해결하였다.

파라메트릭 서치의 개념적인 부분은 [이곳](https://github.com/ahnsh1996/algorithm/blob/master/BinarySearch/%5B%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%5D%20%EC%9E%85%EA%B5%AD%EC%8B%AC%EC%82%AC.md)에서 
어느 정도 적어놓았으니 이를 모르는 사람은 참고하길 바란다.  
~~(설명을 잘 못 하기는 했지만..)~~

아무튼 본 문제에서 파라메트릭 서치를 이용하기 위해서, 고려할 것들이 몇 가지 있다.

1. 무엇을 구할 것인가?  
  : 징검다리를 건널 수 있는 최대 인원  
2. 탐색할 범위를 무엇으로 설정할 것인가?  
  : stones 배열 각 원소들의 값들 중 최솟값 ~ stones 배열 각 원소들의 값들 중 최댓값  
  : min(stones)보다 작은 정답과 max(stones)보다 큰 정답은 나올 수 없기 때문이다.  
3. 정답이 될 가능성이 있는지 확인할 조건(n명이 건널 수 있는지 확인할 조건)  
  : 값이 n 미만인 돌이 k개 연속으로 있는지 체크

1번의 경우 어쩌면 당연한 것이고, 2번의 경우 결과에 지장을 줄 범위만 아니라면 더 큰 범위가 나와도 약간의 효율성 차이일 뿐 대부분 알고리즘이 맞다면 문제 풀이에는 큰 영향을 끼치지 않을 것이다.

결국 파라메트릭 서치의 핵심이 되는 결정 조건인 3번을 어떻게 설계하느냐가 제일 중요하다. 다행히 본 문제에서는 최대 인원이 n명이라고 할 때 크게 n명이 징검다리를 건널 수 있는지 확인할 방법을 
떠올리는 것은 크게 어렵지 않다.

바로 n 미만의 값을 가진 연속된 k개의 돌이 존재하는지를 판단하면 된다. 만약 n보다 작은 값의 돌들이 k개 연속으로 존재한다면 n 번째 사람이 건너기 전에 이미 0인 돌이 k개 이상 있다는 것이므로 
이는 건널 수 없다는 것을 의미한다.

따라서 이러한 조건을 판단해가며 이분 탐색을 실시하면 원하는 결과를 얻을 수 있다.

## 개선사항
카카오 공식 블로그에 O(n) 풀이가 존재한다고 하여 조금 찾아보고 고민해본 결과 슬라이딩 윈도우와 deque를 이용해서 풀이할 수 있었다.

먼저 문제 해결 아이디어는 k개의 연속된 돌로 이루어진 윈도우, 즉 구간들 중에서 최댓값이 최소가 되는 값을 찾는 것이다.

예를 들어서 본 문제의 예시인 `[2, 4, 5, 3, 2, 1, 4, 2, 5, 1]`를 고려해보자. 여기서 `k`는 3이므로 연속된 3개의 돌은  
```
2, 4, 5 → 최댓값 5
4, 5, 3 → 최댓값 5
5, 3, 2 → 최댓값 5
3, 2, 1 → 최댓값 3
2, 1, 4 → 최댓값 4
1, 4, 2 → 최댓값 4
4, 2, 5 → 최댓값 5
2, 5, 1 → 최댓값 5
```
경우가 가능하며, 이때 최댓값이 최소가 되는 경우는 3이므로 3명이 정답이 된다.

이는 각 구간이 모두 0이 되기 위해서는 최댓값 만큼의 사람이 건너야 한다는 소리이기 때문이다. 예를 들어서 `2, 4, 5` 구간의 돌들이 모두 0이 되기 위해선 최댓값인 5명이 건너야 한다는 소리이다.

따라서 징검다리 전체로 본다면 한 개라도 모두 0이 되어 k + 1구간을 건너야 하는 상황이 온다면 그 이상은 건널 수 없다는 것을 의미하기 때문에 가장 빨리 모두 0이 되는 값, 즉 최댓값이 최소가 되는 값을 찾아야 한다는 소리이다.

그렇다면 각 구간의 최댓값을 찾는 과정을 빠르게 수행할 수 있다면 본 문제를 빠르게 해결할 수 있다.

하지만 단순하게 짠다면 구간의 최댓값을 구하기 위해서 반복문 속에서 매번 또 k만큼을 반복해야하기 때문에 효율적으로 이를 구현할 수 없다.

이를 효율적으로 구현하기 위해서 앞, 뒤로 삽입과 삭제가 O(1)인 deque를 사용할 수 있다.

deque에는 k개의 연속된 돌 윈도우가 들어가는데, 항상 윈도우의 최댓값이 deque의 가장 앞에 오도록 만들며 최댓값이 될 가능성이 없는 것은 미리 제거해준다. 
또한 범위 밖의 값을 제거하기 위해서 인덱스를 함께 넣는다.

알고리즘적으로 설명하면

1. deque가 비어있다면 (돌, 인덱스) 쌍을 바로 넣는다.
2. deque가 비어있지 않다면  
  2-1. 맨 앞의 값의 인덱스가 (현재 인덱스 - k)라면 앞에서 제거(popleft)한다. (윈도우 범위 밖의 값을 제거)  
  2-2. deque의 맨 뒤의 돌이 현재 넣으려는 돌보다 크거나 같은 경우를 만날 때까지 뒤에서 제거(pop)한다.
3. (돌, 인덱스) 쌍을 넣는다.
4. deque의 맨 앞의 돌(윈도우의 최댓값)을 비교하여 최솟값을 갱신한다.
5. 모든 윈도우를 확인할 때까지 반복한다.

2-2에서 제거를 하는 이유는 어차피 윈도우들 내에서 최댓값이 될 일이 없기 때문이다. 예를 들어서 [2]가 있을 때 4가 들어온다면 2는 현재 구간에서도 4보다는 작아 최댓값이 될 수 없을 뿐더러 뒤의 구간에서도 4보다 2가 먼저 제거되기 때문이다.

사실 나도 그랬지만 그냥 글만으로는 잘 이해가 가지 않는다. 따라서 위의 예(`[2, 4, 5, 3, 2, 1, 4, 2, 5, 1]`)를 이용하여 다시 보자.

1. index = 0, 처음 deque에는 2가 들어간다.  
  `deque([(2, 0)])`
2. index = 1, 다음에는 4가 들어가는데 4가 들어가면 2는 윈도우(구간) 내에서 최댓값이 될 가능성이 없으므로 pop 해준 후 4를 넣는다.  
  `deque([(4, 1)])`
3. index = 2, 다음에는 5가 들어가는데 5가 들어가면 4는 윈도우(구간) 내에서 최댓값이 될 가능성이 없으므로 pop 해준 후 5를 넣는다.  
  `deque([(5, 2)])`
4. index = 3, 다음에는 3이 deque에 들어간다.  
  `deque([(5, 2), (3, 3)])`
5. index = 4, 다음에는 2가 deque에 들어간다.  
  `deque([(5, 2), (3, 3), (2, 4)])`
6. index = 5, 현재 인덱스가 5인데 아직 deque에 인덱스가 2인 값이 남아있으므로 범위 밖의 값을 제거해주기 위해 이를 제거하고 1이 deque에 들어간다.  
  `deque([(3, 3), (2, 4), (1, 5)])`
7. index = 6, 범위 밖의 값을 제거해주고 4가 들어가려 하는데 모두 4보다 작으므로 pop 해준 후 4를 넣는다.  
  `deque([(4, 6)])`
8. index = 7, 다음에는 2가 deque에 들어간다.  
  `deque([(4, 6), (2, 7)])`
9. index = 8, 다음에는 5가 들어가는데 5가 들어가면 4와 2는 윈도우(구간) 내에서 최댓값이 될 가능성이 없으므로 pop 해준 후 5를 넣는다.  
  `deque([(5, 8)])`
10. index = 9, 다음에는 1이 deque에 들어간다.  
  `deque([(5, 8), (1, 9)])`

이때 3번, 즉 index = k-1일 때부터 deque의 맨 앞 값이 구간의 최댓값이 된다.

이를 이용해서 코딩으로 구현하면 다음과 같다.
```python
from collections import deque
def solution(stones, k):
    dq = deque()
    min_of_max = 200000000
    
    for i in range(k-1): # k - 2번 인덱스까지 규칙에 따라 deque에 삽입
        while dq and dq[-1][0] < stones[i]: dq.pop()
        dq.append((stones[i], i))
    
    for i in range(k-1, len(stones)): # k - 1번 인덱스부터는 윈도우의 최댓값을 비교
        if dq and dq[0][1] == i - k: dq.popleft()
        
        while dq and dq[-1][0] < stones[i]: dq.pop()
        dq.append((stones[i], i))
        
        if min_of_max > dq[0][0]: min_of_max = dq[0][0]
    
    return min_of_max
```

여기서 두 for문을 하나로 합쳐서
```python
for i in range(len(stones)):
    if dq and dq[0][1] == i - k: dq.popleft()
        
    while dq and dq[-1][0] < stones[i]: dq.pop()
    dq.append((stones[i], i))
        
    if i >= k - 1 and min_of_max > dq[0][0]: min_of_max = dq[0][0]
```
로 구현하여 코드의 줄 수를 줄일 수도 있겠지만 이 경우 매번 `i >= k - 1`을 비교해야함과 동시에 인덱스가 k - 1 이후부터 `if dq and dq[0][1] == i - k: dq.popleft()`가 필요한 것이기 때문에 k가 큰 경우 불필요한 비교를 하게 된다. 따라서 이를 따로 빼주면 속도 면에서 더 나은 구현이 될 것이다. 실제로 효율성 테스트에서 유의미한 차이를 보였다.

참고로 평상 시에는 deque를 거의 queue 용도로 사용하는 것과 다르게 본 문제가 파이썬의 deque를 가장 deque 답게 사용한 것 같다.
