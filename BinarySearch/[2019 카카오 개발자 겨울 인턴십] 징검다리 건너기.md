# [2019 카카오 개발자 겨울 인턴십] 징검다리 건너기
## 문제
### 문제 설명
([원본 문제](https://programmers.co.kr/learn/courses/30/lessons/64062)의 내용을 복사한 것입니다.)

카카오 초등학교의 "니니즈 친구들"이 "라이언" 선생님과 함께 가을 소풍을 가는 중에 <b>징검다리</b>가 있는 개울을 만나서 건너편으로 건너려고 합니다. "라이언" 선생님은 "니니즈 친구들"이 무사히 징검다리를 건널 수 있도록 다음과 같이 규칙을 만들었습니다.

* 징검다리는 일렬로 놓여 있고 각 징검다리의 디딤돌에는 모두 숫자가 적혀 있으며 디딤돌의 숫자는 한 번 밟을 때마다 1씩 줄어듭니다.
* 디딤돌의 숫자가 0이 되면 더 이상 밟을 수 없으며 이때는 그 다음 디딤돌로 한번에 여러 칸을 건너 뛸 수 있습니다.
* 단, 다음으로 밟을 수 있는 디딤돌이 여러 개인 경우 무조건 가장 가까운 디딤돌로만 건너뛸 수 있습니다.

"니니즈 친구들"은 개울의 왼쪽에 있으며, 개울의 오른쪽 건너편에 도착해야 징검다리를 건넌 것으로 인정합니다.  
"니니즈 친구들"은 한 번에 한 명씩 징검다리를 건너야 하며, 한 친구가 징검다리를 모두 건넌 후에 그 다음 친구가 건너기 시작합니다.

디딤돌에 적힌 숫자가 순서대로 담긴 배열 stones와 한 번에 건너뛸 수 있는 디딤돌의 최대 칸수 k가 매개변수로 주어질 때, 최대 몇 명까지 징검다리를 건널 수 있는지 return 하도록 solution 함수를 완성해주세요.

### 제한사항
* 징검다리를 건너야 하는 니니즈 친구들의 수는 무제한 이라고 간주합니다.
* stones 배열의 크기는 1 이상 200,000 이하입니다.
* stones 배열 각 원소들의 값은 1 이상 200,000,000 이하인 자연수입니다.
* k는 1 이상 stones의 길이 이하인 자연수입니다.

___

### 입출력 예
|stones|k|result|
|:---|:---|:---|
|[2, 4, 5, 3, 2, 1, 4, 2, 5, 1]|3|3|

### 입출력 예에 대한 설명
**입출력 예 #1**

첫 번째 친구는 다음과 같이 징검다리를 건널 수 있습니다.

![예시1](https://user-images.githubusercontent.com/77680436/117648037-b00ab780-b1c8-11eb-8fce-2bfdba376b80.png)

첫 번째 친구가 징검다리를 건넌 후 디딤돌에 적힌 숫자는 아래 그림과 같습니다.  
두 번째 친구도 아래 그림과 같이 징검다리를 건널 수 있습니다.

![예시2](https://user-images.githubusercontent.com/77680436/117648086-c44eb480-b1c8-11eb-85cd-d27e09141b2b.png)

두 번째 친구가 징검다리를 건넌 후 디딤돌에 적힌 숫자는 아래 그림과 같습니다.  
세 번째 친구도 아래 그림과 같이 징검다리를 건널 수 있습니다.

![예시3](https://user-images.githubusercontent.com/77680436/117648134-d16ba380-b1c8-11eb-8eb2-78beed673c2d.png)

세 번째 친구가 징검다리를 건넌 후 디딤돌에 적힌 숫자는 아래 그림과 같습니다.  
네 번째 친구가 징검다리를 건너려면, 세 번째 디딤돌에서 일곱 번째 디딤돌로 네 칸을 건너뛰어야 합니다. 하지만 k = 3 이므로 건너뛸 수 없습니다.

![예시4](https://user-images.githubusercontent.com/77680436/117648179-dfb9bf80-b1c8-11eb-8410-4b73a9c5ecb3.png)

따라서 최대 3명이 디딤돌을 모두 건널 수 있습니다.

## 제출답안
```python
def check(stones, num, k): # num 미만인 돌이 k개 연속으로 있는지 체크, 즉 num명이 건널 수 있는지 체크
    chk = 0
    for stone in stones:
        chk = chk+1 if stone < num else 0
        if chk == k: return False
    return True

def solution(stones, k):
    answer = 0
    low = min(stones)
    high = max(stones)
    
    while low <= high: # 이분 탐색(파라메트릭 서치)을 진행하며 건널 수 있는 최댓값을 구함
        mid = (low + high) // 2
        if check(stones, mid, k): # 건널 수 있다면
            low = mid + 1 # 더 큰 값이 가능한지 탐색
            answer = mid # 정답 후보로 저장
        else: high = mid - 1

    return answer
```
### 설명
본 문제의 경우 직접 인원을 늘려가면 시뮬레이션을 통해 풀 수도 있겠지만, 이 경우 효율성 검증을 통과할 수 없을 것이다.

따라서 효율적인 풀이를 위해 다양한 방법을 생각해볼 수 있는데, 문제에서 최대로 건널 수 있는 인원을 임의로 설정 했을 때 설정된 인원만큼 무사히 건널 수 있는지 확인할 수 있는 조건이 
명백하여 본 풀이에서는 파라메트릭 서치(이분 탐색)을 이용하여 문제를 해결하였다.

파라메트릭 서치의 개념적인 부분은 [이곳](https://github.com/ahnsh1996/algorithm/blob/master/BinarySearch/%5B%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%5D%20%EC%9E%85%EA%B5%AD%EC%8B%AC%EC%82%AC.md)에서 
어느 정도 적어놓았으니 이를 모르는 사람은 참고하길 바란다.  
~~(설명을 잘 못 하기는 했지만..)~~

아무튼 본 문제에서 파라메트릭 서치를 이용하기 위해서, 고려할 것들이 몇 가지 있다.

1. 무엇을 구할 것인가?  
  : 징검다리를 건널 수 있는 최대 인원  
2. 탐색할 범위를 무엇으로 설정할 것인가?  
  : stones 배열 각 원소들의 값들 중 최솟값 ~ stones 배열 각 원소들의 값들 중 최댓값  
  : min(stones)보다 작은 정답과 max(stones)보다 큰 정답은 나올 수 없기 때문이다.  
3. 정답이 될 가능성이 있는지 확인할 조건(n명이 건널 수 있는지 확인할 조건)  
  : 값이 n 미만인 돌이 k개 연속으로 있는지 체크

1번의 경우 어쩌면 당연한 것이고, 2번의 경우 결과에 지장을 줄 범위만 아니라면 더 큰 범위가 나와도 약간의 효율성 차이일 뿐 대부분 알고리즘이 맞다면 문제 풀이에는 큰 영향을 끼치지 않을 것이다.

결국 파라메트릭 서치의 핵심이 되는 결정 조건인 3번을 어떻게 설계하느냐가 제일 중요하다. 다행히 본 문제에서는 최대 인원이 n명이라고 할 때 크게 n명이 징검다리를 건널 수 있는지 확인할 방법을 
떠올리는 것은 크게 어렵지 않다.

바로 n 미만의 값을 가진 연속된 k개의 돌이 존재하는지를 판단하면 된다. 만약 n보다 작은 값의 돌들이 k개 연속으로 존재한다면 n 번째 사람이 건너기 전에 이미 0인 돌이 k개 이상 있다는 것이므로 
이는 건널 수 없다는 것을 의미한다.

따라서 이러한 조건을 판단해가며 이분 탐색을 실시하면 원하는 결과를 얻을 수 있다.
