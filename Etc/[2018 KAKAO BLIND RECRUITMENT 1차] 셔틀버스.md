# [2018 KAKAO BLIND RECRUITMENT 1차] 셔틀버스
## 문제
### 문제 설명
([원본 문제](https://programmers.co.kr/learn/courses/30/lessons/17678)의 내용을 복사한 것입니다.)

### 셔틀버스

카카오에서는 무료 셔틀버스를 운행하기 때문에 판교역에서 편하게 사무실로 올 수 있다. 카카오의 직원은 서로를 '크루'라고 부르는데, 아침마다 많은 크루들이 이 셔틀을 이용하여 출근한다.

이 문제에서는 편의를 위해 셔틀은 다음과 같은 규칙으로 운행한다고 가정하자.

* 셔틀은 `09:00`부터 총 `n`회 `t`분 간격으로 역에 도착하며, 하나의 셔틀에는 최대 `m`명의 승객이 탈 수 있다.
* 셔틀은 도착했을 때 도착한 순간에 대기열에 선 크루까지 포함해서 대기 순서대로 태우고 바로 출발한다. 예를 들어 `09:00`에 도착한 셔틀은 자리가 있다면 `09:00`에 줄을 선 크루도 탈 수 있다.

일찍 나와서 셔틀을 기다리는 것이 귀찮았던 콘은, 일주일간의 집요한 관찰 끝에 어떤 크루가 몇 시에 셔틀 대기열에 도착하는지 알아냈다. 콘이 셔틀을 타고 사무실로 갈 수 있는 도착 시각 중 제일 늦은 시각을 구하여라.

단, 콘은 게으르기 때문에 같은 시각에 도착한 크루 중 대기열에서 제일 뒤에 선다. 또한, 모든 크루는 잠을 자야 하므로 `23:59`에 집에 돌아간다. 따라서 어떤 크루도 다음날 셔틀을 타는 일은 없다.

### 입력 형식
셔틀 운행 횟수 `n`, 셔틀 운행 간격 `t`, 한 셔틀에 탈 수 있는 최대 크루 수 `m`, 크루가 대기열에 도착하는 시각을 모은 배열 `timetable`이 입력으로 주어진다.

* 0 ＜ `n` ≦ 10
* 0 ＜ `t` ≦ 60
* 0 ＜ `m` ≦ 45
* `timetable`은 최소 길이 1이고 최대 길이 2000인 배열로, 하루 동안 크루가 대기열에 도착하는 시각이 `HH:MM` 형식으로 이루어져 있다.
* 크루의 도착 시각 `HH:MM`은 `00:01`에서 `23:59` 사이이다.

### 출력 형식
콘이 무사히 셔틀을 타고 사무실로 갈 수 있는 제일 늦은 도착 시각을 출력한다. 도착 시각은 `HH:MM` 형식이며, `00:00`에서 `23:59` 사이의 값이 될 수 있다.

### 입출력 예제
|n|t|m|timetable|answer|
|:---|:---|:---|:---|:---|
|1|1|5|["08:00", "08:01", "08:02", "08:03"]|"09:00"|
|2|10|2|["09:10", "09:09", "08:00"]|"09:09"|
|2|1|2|["09:00", "09:00", "09:00", "09:00"]|"08:59"|
|1|1|5|["00:01", "00:01", "00:01", "00:01", "00:01"]|"00:00"|
|1|1|1|["23:59"]|"09:00"|
|10|60|45|["23:59","23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59"]|"18:00"|

## 제출답안
```python
from datetime import datetime, timedelta
def solution(n, t, m, timetable):
    first = datetime.strptime('9', '%H') # 첫 버스 시간(09:00)
    last = (first+timedelta(minutes=(n-1)*t)).strftime('%H:%M') # 마지막 버스 시간
    timetable.sort(reverse=True) # 내림차순 정렬하는 것은 pop 연산을 위해서
    
    for i in range(n):
        bus_time = (first+timedelta(minutes=i*t)).strftime('%H:%M') # 현재 버스 시간
        count = 1
        end = m-1 if i == n-1 else m # 마지막 버스 시간엔 한 자리를 남겨둬야함
        while count <= end and timetable and timetable[-1] <= bus_time: # 현재 버스 시간 이전에 줄 서 있던 사람은 태움
            timetable.pop()
            if not timetable: return last # 대기 중인 크루를 모두 태우고도 남는 경우 막차 시간에 오면 됨
            count += 1

    temp = datetime.strptime(timetable[-1], '%H:%M') - timedelta(minutes=1) # 남은 크루 중 제일 빠른 사람 - 1분
    return last if temp.strftime('%H:%M') > last else temp.strftime('%H:%M') # 위의 경우와 막차 시간 중 빠른 것 반환
```
### 설명
본 문제의 경우 버스를 타는 과정들을 시뮬레이션하여 해결할 수 있다.

알고리즘은 다음과 같다.

1. timetable을 내림차순으로 정렬한다.
2. 첫 차 시간부터 버스가 오는 것을 시뮬레이션 한다.
3. 버스가 왔을 때 timetable을 뒤에서 비교하며(내림차순 이므로) 최대 m명 시간 내에 대기 중인 크루들을 pop한다.
4. 마지막 차 직전 시간까지 t분 간격으로 2번과 3번을 반복한다.
5. 마지막 차 시간에선 3번의 과정을 최대 m-1명까지 pop 한다.
6. 2번 ~ 5번 과정 중 timetable이 빈다면 막차 시간을 반환한다.
7. 6번이 아니라면 timetable 맨 뒤의 시간(내림차순 이므로) - 1분을 한 경우와 막차 시간을 비교하여 더 빠른 것을 반환한다.

먼저 1번의 경우 내림차순 정렬하는 경우는 timetable에 pop 연산을 사용하기 위함이다. 
만약 내림차순 정렬이 아니라 오름차순 정렬을 하고 싶다면 pop이 아니라 인덱스를 늘려가면서 처리를 하는 것이 좋다.

버스를 시뮬레이션 하는 것의 경우는 어렵지 않을 것이다. 단순히 매번 차 시간과 남은 크루 중 제일 빠른 크루의 시간과 비교해가면서 최대 m 명을 태우면(pop) 된다.

여기서 막차 시간에만 최대 m명이 아닌 m-1명을 pop하는데, m명을 태우면 콘이 탈 수가 없기 때문이다. 따라서 최소한 한 자리를 남겨두는 것이다.

이러한 과정을 수행하는 도중 timetable이 비게된다면 이는 대기 중인 크루를 모두 태우고도 남는다는 소리이므로 콘은 막차 시간에 오면 된다.

위의 과정을 수행하고 7번의 경우 `남은 크루들 중 제일 빠른 시간 - 1분`을 수행하고 `막차 시간`과 비교해 더 빠른 시간을 반환한다.  
무조건 `남은 크루들 중 제일 빠른 시간 - 1분`을 반환하지 않는 이유는 마지막 예제와 같이 `남은 크루들 중 제일 빠른 시간 - 1분`이 막차 시간보다도 늦는 경우가 존재하기 때문이다. 
따라서 이러한 경우까지 처리해주기 위해서는 막차 시간과의 비교가 필요하다.

이와 같이 버스를 타는 것을 시뮬레이션 한다면 어렵지 않게 문제를 해결할 수 있다.

## 개선사항
본 문제를 풀이할 때 시간 처리 함수를 만들기 귀찮아서 모듈을 사용하였더니 생각보다 돌아가는 시간 차이가 많이 났다. 아무래도 내가 이용하고자 하는 것만이 아닌 다른 것들이 이것저것 담겨있다 
보니까 그런 것 같다. 그래서 정말 필요한 것들만 간단히 구현하고 이를 이용해 풀이하면 다음과 같다.
```python
def getBusTime(m): # 분을 인자로 받아 HH:MM 포맷으로 반환
    return '%02d:%02d'%divmod(m, 60)

def toMinutes(h, m): # 분으로 변환
    return int(h) * 60 + int(m)
    
def solution(n, t, m, timetable):
    last = getBusTime(540+(n-1)*t) # 막차 시간 (540분은 첫 차 시간인 9시)
    timetable.sort(reverse=True)
    
    for i in range(n):
        bus_time = getBusTime(540+i*t)
        count = 1
        end = m-1 if i == n-1 else m
        while count <= end and timetable and timetable[-1] <= bus_time:
            timetable.pop()
            if not timetable: return last
            count += 1

    temp = getBusTime(toMinutes(*timetable[-1].split(':'))-1)
    return last if temp > last else temp
```
