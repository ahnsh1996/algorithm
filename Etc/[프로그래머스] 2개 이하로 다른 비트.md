# [프로그래머스] 2개 이하로 다른 비트
## 문제
### 문제 설명
([원본 문제](https://programmers.co.kr/learn/courses/30/lessons/77885)의 내용을 복사한 것입니다.)

양의 정수 `x`에 대한 함수 `f(x)`를 다음과 같이 정의합니다.

* `x`보다 크고 `x`와 **비트가 1~2개 다른** 수들 중에서 제일 작은 수

예를 들어,

* `f(2) = 3` 입니다. 다음 표와 같이 2보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 3이기 때문입니다.

|수|비트|다른 비트의 개수|
|:---|:---|:---|
|2|`000...0010`||
|3|`000...0011`|1|

* `f(7) = 11` 입니다. 다음 표와 같이 7보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 11이기 때문입니다.

|수|비트|다른 비트의 개수|
|:---|:---|:---|
|7|`000...0111`||
|8|`000...1000`|4|
|9|`000...1001`|3|
|10|`000...1010`|3|
|11|`000...1011`|2|

정수들이 담긴 배열 `numbers`가 매개변수로 주어집니다. `numbers`의 모든 수들에 대하여 각 수의 `f` 값을 배열에 차례대로 담아 return 하도록 solution 함수를 완성해주세요.

___

### 제한사항
* 1 ≤ `numbers`의 길이 ≤ 100,000
* 0 ≤ `numbers`의 모든 수 ≤ 10<sup>15</sup>

___

### 입출력 예
|numbers|result|
|:---|:---|
|[2,7]|[3,11]|

___

### 입출력 예 설명
**입출력 예#1**  

* 문제 예시와 같습니다.

## 제출답안
```python
def solution(numbers):
    answer = []
    
    for num in numbers:
        f_x = '0' + bin(num)[2:] # 주어진 수를 2진수 문자열로 바꿔서 맨 앞에 '0'을 붙임
        last_zero = f_x.rfind('0') # '0'을 뒤에서부터 찾음
        
        if last_zero == len(f_x) - 1: # '0'이 맨 뒤에 있을 때는 단순히 맨 뒤만 1로 바꿔주면 됨
            f_x = f_x[:-1] + '1'
        else: # 0이 맨 뒤가 아닐 때는 0을 1로 바꾸고 바로 뒤의 1을 0으로 바꿈
            f_x = f_x[:last_zero] + '10' + f_x[last_zero+2:]
        
        answer.append(int(f_x, 2)) 2진수 문자열을 10진수로 변환하여 저장
        
    return answer
```
### 설명
본 문제를 풀기 위해서 처음에는 단순히 1씩 증가하면서 xor 해보고 1의 수를 카운트 해보는 식으로 풀이해봤다.  
(xor의 경우 같으면 0이므로 결과에서 1의 수가 다른 비트의 수이기 때문)

하지만 이는 효율성 측면에서 문제가 있어 규칙을 찾아서 풀어야 함을 깨달았다.

문제를 잘 읽어보니 규칙은 쉽게 찾을 수 있었다.

먼저 문제에서는 `f(x)`를 **`x`보다는 큰 수**라고 정의하고 있다. 이는 `x`의 2진수 문자열에서 가장 먼저 0을 1로 바꾸어야 함을 의미한다.  
왜냐하면 1을 0으로 바꾸는 건 `x`보다 작아지는 것을 의미하기 때문이다.

또한 문제에서는 `f(x)`를 `x`보다 크고 `x`와 비트가 1~2개 다른 수들 중에서 **제일 작은 수**라고 정의하고 있다.  
이는 0을 1로 바꿀 때 가장 자릿수가 작은 값을, 즉 가장 뒤에 있는 0을 1로 바꾸어야 한다는 것을 의미한다. 그래야 값을 키우면서도 최소화하여 키울 수 있기 때문이다.

마지막으로 문제에서는 `f(x)`를 `x`와 **비트가 1~2개 다른 수**라고 정의하고 있다.  
이는 비트를 2개까지 바꿀 수 있다는 의미이므로, 가장 뒤에 있는 0을 1로 바꾼 후, 해당 자리보다 뒤에 있는 1을 0으로 바꿀 수 있다는 것을 의미한다.  
1을 0으로 바꿔 숫자를 더 작게 만들 수 있다면 가능한 가장 앞자리 수의 1을 0으로 바꾸는 것이 가장 숫자를 작게 만드는 일일 것이다.

정리하면 다음과 같다.
```
1. x의 2진수 문자열에서 가장 뒤에 있는 0을 찾는다.
2-1. 해당 0이 2진수 문자열의 맨 끝이라면 단순히 0을 1로 변환한다.
2-2. 해당 0이 2진수 문자열의 맨 끝이 아니라면 0을 1로 변환하고 바로 뒤의 1을 0으로 변환한다.
3. 구한 f(x)의 2진수 문자열을 10진수로 변환하여 저장한다.
```

이를 코드로 구현하면 답안과 같다.
