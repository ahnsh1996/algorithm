# [2018 KAKAO BLIND RECRUITMENT 3차] 자동완성
## 문제
### 문제 설명
([원본 문제](https://programmers.co.kr/learn/courses/30/lessons/17685)의 내용을 복사한 것입니다.)

### 자동완성

포털 다음에서 검색어 자동완성 기능을 넣고 싶은 라이언은 한 번 입력된 문자열을 학습해서 다음 입력 때 활용하고 싶어 졌다. 예를 들어, `go` 가 한 번 입력되었다면, 다음 사용자는 `g` 만 입력해도 `go`를 추천해주므로 `o`를 입력할 필요가 없어진다! 단, 학습에 사용된 단어들 중 앞부분이 같은 경우에는 어쩔 수 없이 다른 문자가 나올 때까지 입력을 해야 한다.  
효과가 얼마나 좋을지 알고 싶은 라이언은 학습된 단어들을 찾을 때 몇 글자를 입력해야 하는지 궁금해졌다.

예를 들어, 학습된 단어들이 아래와 같을 때

```
go
gone
guild
```

* `go`를 찾을 때 `go`를 모두 입력해야 한다.
* `gone`을 찾을 때 `gon` 까지 입력해야 한다. (`gon`이 입력되기 전까지는 `go` 인지 `gone`인지 확신할 수 없다.)
* `guild`를 찾을 때는 `gu` 까지만 입력하면 `guild`가 완성된다.

이 경우 총 입력해야 할 문자의 수는 `7`이다.

라이언을 도와 위와 같이 문자열이 입력으로 주어지면 학습을 시킨 후, 학습된 단어들을 순서대로 찾을 때 몇 개의 문자를 입력하면 되는지 계산하는 프로그램을 만들어보자.

### 입력 형식
학습과 검색에 사용될 중복 없는 단어 `N`개가 주어진다.
모든 단어는 알파벳 소문자로 구성되며 단어의 수 `N`과 단어들의 길이의 총합 `L`의 범위는 다음과 같다.

* 2 <= `N` <= 100,000
* 2 <= `L` <= 1,000,000

### 출력 형식
단어를 찾을 때 입력해야 할 총 문자수를 리턴한다.

### 입출력 예시
|words|result|
|:---|:---|
|["go","gone","guild"]|7|
|["abc","def","ghi","jklm"]|4|
|["word","war","warrior","world"]|15|

### 입출력 설명
* 첫 번째 예제는 본문 설명과 같다.
* 두 번째 예제에서는 모든 단어들이 공통된 부분이 없으므로, 가장 앞글자만 입력하면 된다.
* 세 번째 예제는 총 `15` 자를 입력해야 하고 설명은 아래와 같다.
  * word는 word모두 입력해야 한다.
  * war는 war 까지 모두 입력해야 한다.
  * warrior는 warr 까지만 입력하면 된다.
  * world는 worl까지 입력해야 한다. (word와 구분되어야 함을 명심하자)

## 제출답안
```python
def find(word, trie):
    count = 0
    now = trie
    for char in word:
        if now[1] == 1: return count # 현재까지의 입력만으로도 단어를 찾을 수 있을 때
        now = now[0][char]
        count += 1
    return count # 단어를 모두 입력해야 찾을 수 있을 때

def solution(words):
    answer = 0
    trie = [dict(), 0] # 자신의 트리에 몇 개의 문자열이 있는지 함께 저장
    
    for word in words:
        now = trie
        for char in word:
            if char not in now[0]: now[0][char] = [dict(), 0]
            now[1] += 1
            now = now[0][char]
        now[1] += 1
    
    return sum(find(word, trie) for word in words)
```
### 설명
본 문제의 경우 문자열의 접두사 비교를 얼마나 효율적으로 할 수 있는지 묻는 문제였다. 이런 문제의 경우 트라이 자료구조를 이용하여 쉽게 해결할 수 있다.  
특히 자동완성 기능의 경우 트라이의 활용 중 하나로 유명하기 때문에 문제 해결 아이디어를 떠올리는 것이 어렵지 않았다.

트라이 자료구조의 경우 다른 문제에서도 자주 등장하였기 때문에 이 글에선 설명하지 않는다.([참고](https://github.com/ahnsh1996/algorithm/blob/master/Etc/%5B2020%20KAKAO%20BLIND%20RECRUITMENT%5D%20%EA%B0%80%EC%82%AC%20%EA%B2%80%EC%83%89.md))

아무튼 본 문제에서는 몇 글자를 입력해야 찾으려는 단어가 확실해지는지 묻고 있다. 문제에서 원하는 결과를 얻기 위해서 트라이에 문자열을 삽입할 때 거쳐가는 노드마다 카운트 값을 올려줄 수 있다.

이렇게 한다면 각 노드는 자신을 루트로 하는 트리에 몇 개의 문자열이 저장되어 있는지 알 수 있다.

즉 이러한 식으로 트라이에 저장한다는 것이다.

![트라이 삽입](https://user-images.githubusercontent.com/77680436/117933973-1adcff80-b33d-11eb-994e-f40d4c3e0922.gif)

이러한 방식으로 트라이에 문자열을 삽입한다면 문자열을 찾기 위해 트라이를 따라가다가 해당 노드의 트리부터 문자열이 1개만 저장되어 있는 것을 확인한다면 바로 횟수를 반환하여 최소 입력 횟수를 알 수 있다. 
만약 `go`와 같이 끝까지 문자열이 1개만 저장된 트리를 만나지 못 한다면 모든 글자를 입력해야 해당 단어를 찾을 수 있다는 소리이다.

이를 이용하여 단어를 찾는 최소 입력 횟수를 반환하는 find 함수를 구현하고 모든 단어에 대해 이를 수행해 더해주면 답을 얻을 수 있다.
