# [프로그래머스] 최고의 집합
## 문제
### 문제 설명
([원본 문제](https://programmers.co.kr/learn/courses/30/lessons/12938)의 내용을 복사한 것입니다.)

자연수 n 개로 이루어진 중복 집합(multi set, 편의상 이후에는 "집합"으로 통칭) 중에 다음 두 조건을 만족하는 집합을 최고의 집합이라고 합니다.

1. 각 원소의 합이 S가 되는 수의 집합
2. 위 조건을 만족하면서 각 원소의 곱 이 최대가 되는 집합

예를 들어서 자연수 2개로 이루어진 집합 중 합이 9가 되는 집합은 다음과 같이 4개가 있습니다.  
{ 1, 8 }, { 2, 7 }, { 3, 6 }, { 4, 5 }  
그중 각 원소의 곱이 최대인 { 4, 5 }가 최고의 집합입니다.

집합의 원소의 개수 n과 모든 원소들의 합 s가 매개변수로 주어질 때, 최고의 집합을 return 하는 solution 함수를 완성해주세요.

### 제한사항
* 최고의 집합은 **오름차순으로 정렬된 1차원 배열(list, vector)** 로 return 해주세요.
* 만약 최고의 집합이 존재하지 않는 경우에 **크기가 1인 1차원 배열(list, vector)** 에 `-1` 을 채워서 return 해주세요.
* 자연수의 개수 n은 1 이상 10,000 이하의 자연수입니다.
* 모든 원소들의 합 s는 1 이상, 100,000,000 이하의 자연수입니다.

___

### 입출력 예
|n|s|result|
|:---|:---|:---|
|2|9|[4, 5]|
|2|1|[-1]|
|2|8|[4, 4]|

### 입출력 예 설명

입출력 예#1  
문제의 예시와 같습니다.

입출력 예#2  
자연수 2개를 가지고는 합이 1인 집합을 만들 수 없습니다. 따라서 -1이 들어있는 배열을 반환합니다.

입출력 예#3  
자연수 2개로 이루어진 집합 중 원소의 합이 8인 집합은 다음과 같습니다.

{ 1, 7 }, { 2, 6 }, { 3, 5 }, { 4, 4 }

그중 각 원소의 곱이 최대인 { 4, 4 }가 최고의 집합입니다.

## 제출답안
```python
def solution(n, s):
    # 자연수의 개수가 모든 원소의 합보다 큰 경우
    # 모든 원소를 제일 작은 자연수인 1로 채워도 모든 원소의 합 s를 넘어버리므로 불가능
    if n > s: return [-1]
    
    # 원소의 값들을 최대한 균등하게 함
    element, remainder = divmod(s, n)
    answer = [element for _ in range(n)]
    for i in range(n-1, n-remainder-1, -1):
        answer[i] += 1
    
    return answer
```
### 설명
본 문제에서는 주어진 조건을 만족하는 최고의 (중복)집합을 구하는 문제이다.

사실 조건을 만족시키는 집합을 구하기 위해서 처음에는 값을 하나씩 쪼개는 방식으로 접근하려고 했었다. 하지만 예시를 주의깊게 보니 답이 되는 경우는 원소의 값이 최대한 균등하게, 
즉 통계적으로 고르게 분포되어 있을 때 최고의 집합이 되는 것을 볼 수 있었다.(편차가 작을 때, ~~아마?~~)

원소를 최대한 고르게 분포시키는 것은 생각보다 어렵지 않았다.

1. 만족해야 하는 원소의 합(s)을 자연수의 개수(n)으로 나눈 값을 먼저 모든 원소의 값으로 통일한다.
2. 이후 나눈 나머지의 개수만큼 뒤에서부터 1을 더해준다.(오름차순이어야 하기 때문에)

위와 같은 순서로 진행하면 된다.

예를 들어 `n = 5, s = 37`이라고 한다면 다음과 같다.

1. 7(= 37//5)로 모든 원소를 채워준다. → [7, 7, 7, 7, 7]
2. 뒤에서부터 2(= 37%5)개의 원소에 1을 더해준다. → [7, 7, 7, 8, 8]

이때 2번에서 나머지는 절대로 자연수의 개수(n)보다 클 수 없기 때문에 한 번의 for문이면 무조건 끝이 난다.

위와 같이 풀이한다면 값을 쪼개거나 할 필요 없이 비교적 간단하고 빠르게 답을 구할 수 있기 때문에 효율적으로 풀이할 수 있다.
