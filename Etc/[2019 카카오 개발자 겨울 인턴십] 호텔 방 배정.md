# [2019 카카오 개발자 겨울 인턴십] 호텔 방 배정
## 문제
### 문제 설명
([원본 문제](https://programmers.co.kr/learn/courses/30/lessons/64063)의 내용을 복사한 것입니다.)

"스노우타운"에서 호텔을 운영하고 있는 "스카피"는 호텔에 투숙하려는 고객들에게 방을 배정하려 합니다. 호텔에는 방이 총 k개 있으며, 각각의 방은 1번부터 k번까지 번호로 구분하고 있습니다. 처음에는 모든 방이 비어 있으며 "스카피"는 다음과 같은 규칙에 따라 고객에게 방을 배정하려고 합니다.

1. 한 번에 한 명씩 신청한 순서대로 방을 배정합니다.
2. 고객은 투숙하기 원하는 방 번호를 제출합니다.
3. 고객이 원하는 방이 비어 있다면 즉시 배정합니다.
4. 고객이 원하는 방이 이미 배정되어 있으면 원하는 방보다 번호가 크면서 비어있는 방 중 가장 번호가 작은 방을 배정합니다.

예를 들어, 방이 총 10개이고, 고객들이 원하는 방 번호가 순서대로 [1, 3, 4, 1, 3, 1] 일 경우 다음과 같이 방을 배정받게 됩니다.
|원하는 방 번호|배정된 방 번호|
|:---|:---|
|1|1|
|3|3|
|4|4|
|1|2|
|3|5|
|1|6|

전체 방 개수 k와 고객들이 원하는 방 번호가 순서대로 들어있는 배열 room_number가 매개변수로 주어질 때, 각 고객에게 배정되는 방 번호를 순서대로 배열에 담아 return 하도록 solution 함수를 완성해주세요.

### 제한사항
* k는 1 이상 10<sup>12</sup> 이하인 자연수입니다.
* room_number 배열의 크기는 1 이상 200,000 이하입니다.
* room_number 배열 각 원소들의 값은 1 이상 k 이하인 자연수입니다.
* room_number 배열은 모든 고객이 방을 배정받을 수 있는 경우만 입력으로 주어집니다.
  * 예를 들어, k = 5, room_number = [5, 5] 와 같은 경우는 방을 배정받지 못하는 고객이 발생하므로 이런 경우는 입력으로 주어지지 않습니다.

___

### 입출력 예
|k|room_number|result|
|:---|:---|:---|
|10|[1,3,4,1,3,1]|[1,3,4,2,5,6]|

### 입출력 예에 대한 설명
**입출력 예 #1**

문제의 예시와 같습니다.

첫 번째 ~ 세 번째 고객까지는 원하는 방이 비어 있으므로 즉시 배정받을 수 있습니다. 네 번째 고객의 경우 1번 방을 배정받기를 원했는데, 1번 방은 빈 방이 아니므로, 1번 보다 번호가 크고 비어 있는 방 중에서 가장 번호가 작은 방을 배정해야 합니다. 1번 보다 번호가 크면서 비어있는 방은 [2번, 5번, 6번...] 방이며, 이중 가장 번호가 작은 방은 2번 방입니다. 따라서 네 번째 고객은 2번 방을 배정받습니다. 마찬가지로 5, 6번째 고객은 각각 5번, 6번 방을 배정받게 됩니다.

## 제출답안
```python
def solution(k, room_number):
    answer = []
    room = dict() # 방 번호 별 요청 시 배정해 줄 방 저장

    for num in room_number:
        temp = [num] # room의 내용을 갱신할 방 번호들(계산 중 거쳐간 번호들)
        while num in room: # 배정되지 않은 방을 찾을 때까지
            num = room[num] # room의 내용을 따라 배정할 방을 찾음
            temp.append(num) # 거쳐간 방 번호들 저장
        for n in temp: room[n] = temp[-1] + 1 # 배정할 방을 찾기 위해 거쳐온 방들의 room 값 수정
        answer.append(num)

    return answer
```
### 설명
본 문제의 경우 `메모이제이션`을 통하여 같은 계산을 반복하지 않도록 하는 것이 핵심인 문제이다.  
알고리즘을 공부하였다면 보통 동적 프로그래밍에서 `메모이제이션`이라는 말을 들어봤을 것이다. 메모이제이션의 사전적 정의<sup>[1]</sup>는 다음과 같다.
```
메모이제이션(memoization)은 컴퓨터 프로그램이 동일한 계산을 반복해야 할 때, 
이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술이다.
```

사전적 정의에서 알려주듯이 메모이제이션은 '동일한 계산을 반복해야 할 때, 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거'하는 것이다.  
이러한 메모이제이션은 본 문제를 해결하기 위한 핵심 원리가 된다.

먼저 메모이제이션이 없을 때 일반적으로 본 문제를 해결하는 방법을 생각해보자.
```python
def solution(k, room_number):
    answer = []
    room = set() # 배정된 방을 저장

    for num in room_number:
        while num in room: num += 1
        room.add(num)
        answer.append(num)

    return answer
```
아마도 위와 같이 구현하는 것이 가장 간단하면서, 비교적 합리적인 성능(방이 배정되어 있는지 확인하는 과정이 O(1)이기 때문에)을 낼 것이다.

하지만 위의 방법 역시 효율성 측정 부분에서는 시간 초과가 난다. 이는 같은 계산을 반복해서 수행하기 때문이다.  
예를 들어 1부터 100,000까지 이미 방이 배정되어 있다고 생각해보자. 이때, 1을 배정받길 원하는 사람이 100,000명이라고 한다면 1부터 100,000까지 방이 배정되어 있는지 확인하는 과정을 100,000번 
반복해야한다. 즉, 같은 계산을 여러 번 반복하고 있는 것이다.

같은 계산을 반복하고 있다면 이를 저장하여 동일한 계산을 하지 않도록 해주면 이를 해결할 수 있을 것 같다. 즉, 이는 처음에 살펴보았던 메모이제이션을 활용한다는 것을 의미한다.
이를 위해서 `room`이라는 변수는 방 번호 별로 요청 시 배정해 줄 방을 저장하는 딕셔너리로 설정한다. 
예를 들어서 `{1: 2}`는 1번 방을 요청했을 때, 2번 방을 배정해준다는 것과 1번 방이 이미 배정되어 있다는 두 가지를 의미하는 것이다. 
이처럼 `room` 변수에 방을 배정하고 요청한 번호에 `배정한 방 + 1`을 저장한다. 이후 room에 있는 값을 따라서 방을 배정해준다.

예를 들어서 `{1: 2, 2: 3, 3: 4}`일 때 1번 방을 요청한다면

1. room[1] = 2
2. room[2] = 3
3. room[3] = 4

의 과정을 통해 4번 방을 배정하는 것이다.

이제 이러한 구조에 메모이제이션을 어떠한 방식으로 할지 결정해야 한다. 여기서 나는 3가지 시도를 해보았다.

1. 고객이 요청한 방 번호와 마지막 배정한 방 번호의 room 값만 수정하는 방식  
`{1: 2, 2: 3, 3: 4}`일 때 1번 방을 요청한다면 배정 후 `{1: 5, 2: 3, 3: 4, 4: 5}`가 되는 것

2. 값을 증가시켜가며 값을 따라가는 방식  
`{1: 2, 2: 3, 3: 4}`일 때 1번 방을 요청한다면 배정 후 `{1: 3, 2: 4, 3: 5, 4: 5}`가 되는 것

3. 거쳐온 값을 저장했다가 모두 갱신하는 방식  
`{1: 2, 2: 3, 3: 4}`일 때 1번 방을 요청한다면 배정 후 `{1: 5, 2: 5, 3: 5, 4: 5}`가 되는 것

수행 결과만 보면 3번이 당연히 이득일 것 같고 결과적으로 3번 방식으로 문제를 해결할 수 있었으나, 바로 이를 선택하지 않고 1번, 2번 방식을 시도해본 이유는 거쳐온 값을 저장하고 이를 갱신하기 위한 반복문을 추가로 
도는 오버헤드를 감수하고도 충분한 이득이 될지 헷갈렸기 때문이다.

어쨌든 결과적으로 3번 방식으로 시도한 경우만 성공하였고, 답은 3번 방식이 되었다.

## 참고
[1] 위키백과, "메모이제이션", https://ko.wikipedia.org/wiki/%EB%A9%94%EB%AA%A8%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98
