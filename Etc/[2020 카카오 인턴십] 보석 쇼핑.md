# [2020 카카오 인턴십] 보석 쇼핑
## 문제
### 문제 설명
([원본 문제](https://programmers.co.kr/learn/courses/30/lessons/67258)의 내용을 복사한 것입니다.)

개발자 출신으로 세계 최고의 갑부가 된 `어피치`는 스트레스를 받을 때면 이를 풀기 위해 오프라인 매장에 쇼핑을 하러 가곤 합니다.  
어피치는 쇼핑을 할 때면 매장 진열대의 특정 범위의 물건들을 모두 싹쓸이 구매하는 습관이 있습니다.  
어느 날 스트레스를 풀기 위해 보석 매장에 쇼핑을 하러 간 어피치는 이전처럼 진열대의 특정 범위의 보석을 모두 구매하되 특별히 아래 목적을 달성하고 싶었습니다.  
`진열된 모든 종류의 보석을 적어도 1개 이상 포함하는 가장 짧은 구간을 찾아서 구매`

예를 들어 아래 진열대는 4종류의 보석(RUBY, DIA, EMERALD, SAPPHIRE) 8개가 진열된 예시입니다.

|진열대 번호|1|2|3|4|5|6|7|8|
|:---|:---|:---|:---|:---|:---|:---|:---|:---|
|보석 이름|DIA|RUBY|RUBY|DIA|DIA|EMERALD|SAPPHIRE|DIA|

진열대의 3번부터 7번까지 5개의 보석을 구매하면 모든 종류의 보석을 적어도 하나 이상씩 포함하게 됩니다.

진열대의 3, 4, 6, 7번의 보석만 구매하는 것은 중간에 특정 구간(5번)이 빠지게 되므로 어피치의 쇼핑 습관에 맞지 않습니다.

진열대 번호 순서대로 보석들의 이름이 저장된 배열 gems가 매개변수로 주어집니다. 이때 모든 보석을 하나 이상 포함하는 가장 짧은 구간을 찾아서 return 하도록 solution 함수를 완성해주세요.  
가장 짧은 구간의 `시작 진열대 번호`와 `끝 진열대 번호`를 차례대로 배열에 담아서 return 하도록 하며, 만약 가장 짧은 구간이 여러 개라면 `시작 진열대 번호`가 가장 작은 구간을 return 합니다.

### [제한사항]
* gems 배열의 크기는 1 이상 100,000 이하입니다.
  * gems 배열의 각 원소는 진열대에 나열된 보석을 나타냅니다.
  * gems 배열에는 1번 진열대부터 진열대 번호 순서대로 보석이름이 차례대로 저장되어 있습니다.
  * gems 배열의 각 원소는 길이가 1 이상 10 이하인 알파벳 대문자로만 구성된 문자열입니다.

___

### 입출력 예
|gems|result|
|:---|:---|
|`["DIA", "RUBY", "RUBY", "DIA", "DIA", "EMERALD", "SAPPHIRE", "DIA"]`|[3, 7]|
|`["AA", "AB", "AC", "AA", "AC"]`|[1, 3]|
|`["XYZ", "XYZ", "XYZ"]`|[1, 1]|
|`["ZZZ", "YYY", "NNNN", "YYY", "BBB"]`|[1, 5]|

### 입출력 예에 대한 설명
**입출력 예 #1**

문제 예시와 같습니다.

**입출력 예 #2**

3종류의 보석(AA, AB, AC)을 모두 포함하는 가장 짧은 구간은 [1, 3], [2, 4]가 있습니다.  
`시작 진열대 번호`가 더 작은 [1, 3]을 return 해주어야 합니다.

**입출력 예 #3**

1종류의 보석(XYZ)을 포함하는 가장 짧은 구간은 [1, 1], [2, 2], [3, 3]이 있습니다.  
`시작 진열대 번호`가 가장 작은 [1, 1]을 return 해주어야 합니다.

**입출력 예 #4**

4종류의 보석(ZZZ, YYY, NNNN, BBB)을 모두 포함하는 구간은 [1, 5]가 유일합니다.  
그러므로 [1, 5]를 return 해주어야 합니다.

## 제출답안
```python
from collections import Counter
def solution(gems):
    answer = [0, len(gems)]
    start = end = 0
    total = len(set(gems)) # 총 보석 개수
    count = Counter() # start ~ end 범위 안에 있는 각 보석들의 개수(없으면 0을 표시하지 않고 아예 count에 없음)

    while True:
        while end < len(gems) and len(count) < total: # 범위 안에 모든 보석 종류가 포함될 때까지 end를 증가시킴
            count[gems[end]] += 1
            end += 1

        if len(count) < total: break # 만약 끝까지 end를 늘렸음에도 모든 보석을 포함하는 구간이 더 존재하지 않는다면 탐색 종료

        while start < len(gems) and len(count) == total: # 범위 안에 모든 보석 종류가 포함되는 동안 범위를 줄임(start 증가)
            count[gems[start]] -= 1
            if not count[gems[start]]: del count[gems[start]] # 범위가 줄어들면서 보석이 0개가 되면 키 값에서 삭제
            start += 1
    
        if answer[1] - answer[0] > end - start: # 현재 구한 모든 보석을 포함하는 구간이 기존의 구간보다 더 최적해이면 정답 갱신
            answer = [start, end]

    return answer
```
### 설명
본 문제의 경우 모든 보석을 포함하는 구간들을 찾고 이 중에서 가장 짧은 것을 도출하는 문제이다. 이를 위해서 단순하게 완전 탐색을 수행할 수도 있겠지만 그렇게 한다면 효율성 검사에서 통과하지 못 할 것이다.

효율성 검사에서 통과하기 위해서는 투 포인터를 통해 각각의 포인터를 조작해가면서 풀어야 시간 내에 정답을 얻을 수 있다.

투 포인터를 이용한 문제 해결 알고리즘은 다음과 같다.

1. 구간의 시작을 가리키는 start 포인터와 구간의 끝을 가리키는 end 포인터를 리스트의 처음인 0으로 초기화 한다.
2. 구간 내의 보석의 수를 세는 count 변수를 만든다.(해시 테이블 형태의 자료구조가 적합)
3. count에 보석을 추가해가며 구간 내에 모든 종류의 보석이 포함될 때까지 end를 증가시킨다.(오른쪽 범위를 늘림)
4. count에 보석을 감소해가며 구간 내에 모든 종류의 보석이 포함되는 동안 start를 증가시킨다.(왼쪽 범위를 줄임)
5. 3번과 4번을 통해 모든 보석 종류를 포함하는 적당한 구간을 구했다면 기존의 답보다 최적해인지 비교하여 갱신한다.
6. 더 이상 모든 보석 종류를 포함하는 다른 구간이 존재하지 않을 때까지 3번 ~ 5번을 반복한다.  
  (3번에서 end를 gems의 끝까지 증가시켰음에도 모든 보석이 포함되지 않을 때까지)

알고리즘을 요약하자면 모든 보석을 포함할 때까지 오른쪽 범위를 늘리고, 다음에는 왼쪽 범위를 줄여서 구간을 구하는 과정을 반복하는 것이다.

다음은 알고리즘에 따라 구간을 구하는 과정의 예시이다.
```
 ↓                                                          start
[A, B, E, C, D, A, F, D, F, D, F, D, D, E, A, B, C, F, D, C]
 ↑                                                          end
 
1. start, end를 0으로 초기화하고 시작

------------------------------------------------------------------
 ↓                                                          start
[A, B, E, C, D, A, F, D, F, D, F, D, D, E, A, B, C, F, D, C]
                   ↑                                        end

2. 모든 종류의 보석을 포함할 때까지 end를 증가

------------------------------------------------------------------
    ↓                                                       start
[A, B, E, C, D, A, F, D, F, D, F, D, D, E, A, B, C, F, D, C]
                   ↑                                        end
3. 모든 종류의 보석을 포함하는 동안 start를 증가
4. 현재 답([2, 7]), 기존 답([1, 20]) 이므로 정답 갱신

------------------------------------------------------------------
       ↓                                                    start
[A, B, E, C, D, A, F, D, F, D, F, D, D, E, A, B, C, F, D, C]
                                              ↑             end
5. 다음 구간을 구하기 위하여 start를 한 칸 증가시킨 후,
   다시 모든 보석을 포함할 때까지 end 증가

------------------------------------------------------------------
          ↓                                                 start
[A, B, E, C, D, A, F, D, F, D, F, D, D, E, A, B, C, F, D, C]
                                              ↑             end
6. 모든 종류의 보석을 포함하는 동안 start를 증가
7. 현재 답([4, 16]), 기존 답([2, 7]) 이므로 기존 정답 유지

------------------------------------------------------------------
             ↓                                              start
[A, B, E, C, D, A, F, D, F, D, F, D, D, E, A, B, C, F, D, C]
                                                 ↑          end
8. 다음 구간을 구하기 위하여 start를 한 칸 증가시킨 후,
   다시 모든 보석을 포함할 때까지 end 증가
   
------------------------------------------------------------------
                               ↓                            start
[A, B, E, C, D, A, F, D, F, D, F, D, D, E, A, B, C, F, D, C]
                                                 ↑          end
9. 모든 종류의 보석을 포함하는 동안 start를 증가
10. 현재 답([11, 17]), 기존 답([2, 7]) 이므로 기존 정답 유지
   
------------------------------------------------------------------
                                  ↓                         start
[A, B, E, C, D, A, F, D, F, D, F, D, D, E, A, B, C, F, D, C]
                                                    ↑       end
11. 다음 구간을 구하기 위하여 start를 한 칸 증가시킨 후,
    다시 모든 보석을 포함할 때까지 end 증가

------------------------------------------------------------------
                                     ↓                      start
[A, B, E, C, D, A, F, D, F, D, F, D, D, E, A, B, C, F, D, C]
                                                    ↑       end
12. 모든 종류의 보석을 포함하는 동안 start를 증가
13. 현재 답([13, 18]), 기존 답([2, 7]) 이므로 시작 번호가 앞서는 기존 정답 유지

------------------------------------------------------------------
                                        ↓                   start
[A, B, E, C, D, A, F, D, F, D, F, D, D, E, A, B, C, F, D, C]
                                                       ↑    end
14. 다음 구간을 구하기 위하여 start를 한 칸 증가시킨 후,
    다시 모든 보석을 포함할 때까지 end 증가
   
------------------------------------------------------------------
                                        ↓                   start
[A, B, E, C, D, A, F, D, F, D, F, D, D, E, A, B, C, F, D, C]
                                                       ↑    end
14. 모든 종류의 보석을 포함하는 동안 start를 증가
15. 현재 답([14, 19]), 기존 답([2, 7]) 이므로 시작 번호가 앞서는 기존 정답 유지

------------------------------------------------------------------
                                           ↓                start
[A, B, E, C, D, A, F, D, F, D, F, D, D, E, A, B, C, F, D, C]
                                                          ↑ end
16. 다음 구간을 구하기 위하여 start를 한 칸 증가시킨 후,
    end를 끝까지 증가시켰으나 더 이상 모든 종류를 포함하는 구간은 없으므로 탐색을 종료한다.
```

위와 같이 최종 정답으로 [2, 7]을 구할 수 있다. 이를 코딩으로 구현하면 제출 답안과 같다.
