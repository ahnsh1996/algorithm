# [2020 카카오 인턴십] 수식 최대화
## 문제
### 문제 설명
([원본 문제](https://programmers.co.kr/learn/courses/30/lessons/67257)의 내용을 복사한 것입니다.)

IT 벤처 회사를 운영하고 있는 `라이언`은 매년 사내 해커톤 대회를 개최하여 우승자에게 상금을 지급하고 있습니다.  
이번 대회에서는 우승자에게 지급되는 상금을 이전 대회와는 다르게 다음과 같은 방식으로 결정하려고 합니다.  
해커톤 대회에 참가하는 모든 참가자들에게는 숫자들과 3가지의 연산문자(`+, -, *`) 만으로 이루어진 연산 수식이 전달되며, 참가자의 미션은 전달받은 수식에 포함된 연산자의 우선순위를 자유롭게 재정의하여 만들 수 있는 가장 큰 숫자를 제출하는 것입니다.  
단, 연산자의 우선순위를 새로 정의할 때, 같은 순위의 연산자는 없어야 합니다. 즉, `+` > `-` > `*` 또는 `-` > `*` > `+` 등과 같이 연산자 우선순위를 정의할 수 있으나 `+,*` > `-` 또는 `*` > `+,-`처럼 2개 이상의 연산자가 동일한 순위를 가지도록 연산자 우선순위를 정의할 수는 없습니다. 수식에 포함된 연산자가 2개라면 정의할 수 있는 연산자 우선순위 조합은 2! = 2가지이며, 연산자가 3개라면 3! = 6가지 조합이 가능합니다.  
만약 계산된 결과가 음수라면 해당 숫자의 절댓값으로 변환하여 제출하며 제출한 숫자가 가장 큰 참가자를 우승자로 선정하며, 우승자가 제출한 숫자를 우승상금으로 지급하게 됩니다.

예를 들어, 참가자 중 네오가 아래와 같은 수식을 전달받았다고 가정합니다.

`"100-200*300-500+20"`

일반적으로 수학 및 전산학에서 약속된 연산자 우선순위에 따르면 더하기와 빼기는 서로 동등하며 곱하기는 더하기, 빼기에 비해 우선순위가 높아 `*` > `+,-` 로 우선순위가 정의되어 있습니다.  
대회 규칙에 따라 `+` > `-` > `*` 또는 `-` > `*` > `+` 등과 같이 연산자 우선순위를 정의할 수 있으나 `+,*` > `-` 또는 `*` > `+,-` 처럼 2개 이상의 연산자가 동일한 순위를 가지도록 연산자 우선순위를 정의할 수는 없습니다.  
수식에 연산자가 3개 주어졌으므로 가능한 연산자 우선순위 조합은 3! = 6가지이며, 그 중 `+` > `-` > `*` 로 연산자 우선순위를 정한다면 결괏값은 22,000원이 됩니다.  
반면에 `*` > `+` > `-` 로 연산자 우선순위를 정한다면 수식의 결괏값은 -60,420 이지만, 규칙에 따라 우승 시 상금은 절댓값인 60,420원이 됩니다.

참가자에게 주어진 연산 수식이 담긴 문자열 expression이 매개변수로 주어질 때, 우승 시 받을 수 있는 가장 큰 상금 금액을 return 하도록 solution 함수를 완성해주세요.

### [제한사항]
* expression은 길이가 3 이상 100 이하인 문자열입니다.
* expression은 공백문자, 괄호문자 없이 오로지 숫자와 3가지의 연산자(`+, -, *`) 만으로 이루어진 올바른 중위표기법(연산의 두 대상 사이에 연산기호를 사용하는 방식)으로 표현된 연산식입니다. 잘못된 연산식은 입력으로 주어지지 않습니다.
  * 즉, `"402+-561*"`처럼 잘못된 수식은 올바른 중위표기법이 아니므로 주어지지 않습니다.
* expression의 피연산자(operand)는 0 이상 999 이하의 숫자입니다.
  * 즉, `"100-2145*458+12"`처럼 999를 초과하는 피연산자가 포함된 수식은 입력으로 주어지지 않습니다.
  * `"-56+100"`처럼 피연산자가 음수인 수식도 입력으로 주어지지 않습니다.
* expression은 적어도 1개 이상의 연산자를 포함하고 있습니다.
* 연산자 우선순위를 어떻게 적용하더라도, expression의 중간 계산값과 최종 결괏값은 절댓값이 2<sup>63</sup> - 1 이하가 되도록 입력이 주어집니다.
* 같은 연산자끼리는 앞에 있는 것의 우선순위가 더 높습니다.

___

### 입출력 예
|expression|result|
|:---|:---|
|`"100-200*300-500+20"`|60420|
|`"50*6-3*2"`|300|

### 입출력 예에 대한 설명
**입출력 예 #1**  
`*` > `+` > `-` 로 연산자 우선순위를 정했을 때, 가장 큰 절댓값을 얻을 수 있습니다.  
연산 순서는 아래와 같습니다.  
`100-200*300-500+20`  
= `100-(200*300)-500+20`  
= `100-60000-(500+20)`  
= `(100-60000)-520`  
= `(-59900-520)`  
= `-60420`  
따라서, 우승 시 받을 수 있는 상금은 |-60420| = 60420 입니다.

**입출력 예 #2**  
`-` > `*` 로 연산자 우선순위를 정했을 때, 가장 큰 절댓값을 얻을 수 있습니다.  
연산 순서는 아래와 같습니다.(expression에서 `+` 연산자는 나타나지 않았으므로, 고려할 필요가 없습니다.)  
`50*6-3*2`  
= `50*(6-3)*2`  
= `(50*3)*2`  
= `150*2`  
= `300`  
따라서, 우승 시 받을 수 있는 상금은 300 입니다.

## 제출답안
```python
import re
from itertools import permutations
def toPostfix(tokens, priority): # 주어진 우선순위에 따라 후위 표기법으로 변환
    result = []
    stack = []

    for token in tokens:
        if token.isdigit(): result.append(int(token)) # 토큰이 숫자일 때 결과식에 바로 추가
        else: # 토큰이 연산자일 때
            while stack and priority[stack[-1]] >= priority[token]: # 자신보다 크거나 같은 연산자를 모두 pop하여 결과식에 추가한 후
                result.append(stack.pop())
            stack.append(token) # 스택에 연산자 추가

    while stack: result.append(stack.pop()) # 위의 과정을 거치고 남은 연산자를 결과식에 추가

    return result

def calculate(tokens): # 후위 표기법으로 표시된 식을 계산
    stack = []

    for token in tokens:
        if type(token) == int: stack.append(token) # 토큰이 숫자일 때 스택에 삽입
        else: # 토큰이 연산자일 때 스택의 탑에 있는 두 개의 수를 계산하여 결과를 스택에 삽입
            n2, n1 = stack.pop(), stack.pop()
            op = token
            result = n1*n2 if op == '*' else n1+n2 if op == '+' else n1-n2
            stack.append(result)

    return abs(stack[0])

def solution(expression):
    tokens = re.findall('([0-9]+|[-*+])', expression) # 주어진 식을 토큰화
    op = {token for token in tokens if not token.isdigit()} # 토큰을 탐색하여 연산자가 무엇이 있는지 추출
    maxVal = 0 # 우승 시 받을 수 있는 가장 큰 상금 금액

    for perm in permutations(op, len(op)): # 연산자로 나올 수 있는 모든 순열 탐색(모든 우선순위 탐색)
        priority = {perm[i]: i for i in range(len(op))} # 현재 순열의 순서에 따라 우선순위 부여
        result = calculate(toPostfix(tokens, priority)) # 우선순위에 따라 후위 표기법으로 변환 후 계산
        if maxVal < result: maxVal = result

    return maxVal
```
### 설명
본 문제의 경우 연산자의 우선순위에 따라 계산하는 것을 구현하고, 이를 완전 탐색하여 답을 찾는 문제이다.

카카오에서는 연산자의 우선순위에 따라 계산하는 방법으로 `'문자열의 앞에서부터 차례대로 우선순위가 빠른 연산자부터 찾아서 그 연산자와 양 옆의 숫자(피연산자) 2개를 제거하고 계산된 결괏값을 대입하는 과정을 반복'`하는 방식을 
설명해주고 있다.

물론 이러한 방법도 가능하지만, 본 풀이에서는 컴퓨터가 계산하기 쉬운 후위 표기법으로 변환하고 이를 계산하는 방법을 사용하였다.  
후위 표기법은 연산자를 피연산자의 뒤에 표기하는 방법을 말한다. 우리가 실생활에서 사용하고 있는 방법은 연산자를 피연산자 중간에 표기하는 중위 표기법이다.  
`ex) 중위 표기법: a+b / 후위 표기법: ab+`

이러한 후위 표기법은 사람이 보기에는 불편하다는 단점이 있지만, 스택을 이용하여 식을 단순히 왼쪽에서부터 오른쪽으로 쭉 계산하면 된다는 장점이 있다.

따라서 본 풀이에서는 연산자의 우선순위를 고려하여 각각의 후위 표기법을 만들고, 이를 계산하여 비교하는 방법을 사용하였다.

중위 표기법을 후위 표기법으로 변환하는 방법은 다음과 같다.  
(본 문제에서는 괄호는 존재하지 않기 때문에 고려하지 않는다.)

1. 피연산자(숫자)일 경우 바로 결과식에 추가한다.
2. 연산자일 경우  
  2-1. 스택이 비어있다면 스택에 push한다.
  2-2. 스택이 비어있지 않다면 스택의 탑이 현재 연산자보다 우선순위가 작은 연산자가 될 때까지 모두 pop하여 결과식에 추가한 후 push한다.
3. 1 ~ 2의 과정을 수식이 끝날 때까지 반복한다.
4. 수식이 끝날 때까지 스택이 비어있지 않다면 스택에 남은 연산자들을 모두 pop하여 결과식에 추가한다.

예를 들어 `"100-200*300-500+20"` 식에서 연산자 우선순위가 	`*` > `+` > `-`라고 한다면 후위 표기법으로 변환하는 과정은 다음과 같다.

1. 첫 번째 토큰으로 `100`이 들어온다. 이는 피연산자이므로 바로 결과식에 추가한다.  
`결과식: 100 / 스택: [] ← top`

2. 두 번째 토큰으로 `-`가 들어온다. 이는 연산자이며 스택이 비어있으므로 스택에 push한다.  
`결과식: 100 / 스택: [-] ← top`

3. 세 번째 토큰으로 `200`이 들어온다. 이는 피연산자이므로 바로 결과식에 추가한다.  
`결과식: 100200 / 스택: [-] ← top`

4. 네 번째 토큰으로 `*`이 들어온다. 이는 연산자이며 현재 스택에 탑(`-`)이 토큰(`*`)보다 우선순위가 낮으므로 pop 없이 토큰을 스택에 push한다.  
`결과식: 100200 / 스택: [-, *] ← top`

5. 다섯 번째 토큰으로 `300`이 들어온다. 이는 피연산자이므로 바로 결과식에 추가한다.  
`결과식: 100200300 / 스택: [-, *] ← top`

6. 여섯 번째 토큰으로 `-`가 들어온다. 이는 연산자이며 현재 스택에 들어있는 값들은 모두 우선순위가 크거나 같으므로 모두 pop하여 결과식에 추가하고, 토큰을 push한다.  
`결과식: 100200300*- / 스택: [-] ← top`

7. 일곱 번째 토큰으로 `500`이 들어온다. 이는 피연산자이므로 바로 결과식에 추가한다.  
`결과식: 100200300*-500 / 스택: [-] ← top`

8. 여덟 번째 토큰으로 `+`이 들어온다. 이는 연산자이며 현재 스택에 탑(`-`)이 토큰(`+`)보다 우선순위가 낮으므로 pop 없이 토큰을 스택에 push한다.  
`결과식: 100200300*-500 / 스택: [-, +] ← top`

9. 아홉 번째 토큰으로 `20`이 들어온다. 이는 피연산자이므로 바로 결과식에 추가한다.  
`결과식: 100200300*-50020 / 스택: [-, +] ← top`

10. 수식이 끝났음에도 스택에 값이 남아있으므로 모두 pop하여 결과식에 추가한다.  
`결과식: 100200300*-50020+- / 스택: [] ← top`

이렇게 최종 결과 `"100-200*300-500+20" → "100200300*-50020+-"`로 변환된다.

이번에는 이렇게 변환한 후위 표기법을 계산하는 방법은 다음과 같다.

1. 피연산자(숫자)일 경우 스택에 push한다.
2. 연산자일 경우 스택의 탑에 있는 두 개의 수를 pop하여 계산한 후 다시 스택에 삽입한다.  
(먼저 pop한 것이 두 번째 피연산자이다.)
3. 위의 과정을 수식을 모두 스캔할 동안 반복한다.

위와 같이 계산한다면 스택에 남는 값은 최종적인 계산 결과만 남게될 것이다.

위에서 후위표기법으로 변환하였던 `"100200300*-50020+-"`의 식을 계산하는 과정은 다음과 같다.

1. 첫 번째 토큰이 피연산자(`100`)이므로 스택에 push한다.  
`스택: [100] ← top`

2. 두 번째 토큰이 피연산자(`200`)이므로 스택에 push한다.  
`스택: [100, 200] ← top`

3. 세 번째 토큰이 피연산자(`300`)이므로 스택에 push한다.  
`스택: [100, 200, 300] ← top`

4. 네 번째 토큰이 연산자(`*`)이므로 스택의 두 값을 pop하여 계산(`200*300`)한 후 결과(`60000`)를 push한다.  
`스택: [100, 60000] ← top`

5. 다섯 번째 토큰이 연산자(`-`)이므로 스택의 두 값을 pop하여 계산(`100-60000`)한 후 결과(`-59900`)를 push한다.  
`스택: [-59900] ← top`

6. 여섯 번째 토큰이 피연산자(`500`)이므로 스택에 push한다.  
`스택: [-59900, 500] ← top`

7. 일곱 번째 토큰이 피연산자(`20`)이므로 스택에 push한다.  
`스택: [-59900, 500, 20] ← top`

8. 여덟 번째 토큰이 연산자(`+`)이므로 스택의 두 값을 pop하여 계산(`500+20`)한 후 결과(`520`)를 push한다.  
`스택: [-59900, 520] ← top`

9. 아홉 번째 토큰이 연산자(`-`)이므로 스택의 두 값을 pop하여 계산(`-59900-520`)한 후 결과(`-60420`)를 push한다.  
`스택: [-60420] ← top`

10. 수식이 끝났으므로 스택에 남은 값(`-60420`)은 최종 계산 결과이다.

계산 결과, 입출력 예 1번과 같은 결과를 얻은 것을 확인할 수 있다.

이처럼 후위 표기법으로의 변환과 후위 표기법의 계산을 구현하고나면 나머지는 가능한 모든 경우를 탐색하여 결과를 도출하면 된다.
