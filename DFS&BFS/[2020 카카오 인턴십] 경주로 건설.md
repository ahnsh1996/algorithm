# [2020 카카오 인턴십] 경주로 건설
## 문제
### 문제 설명
([원본 문제](https://programmers.co.kr/learn/courses/30/lessons/67259)의 내용을 복사한 것입니다.)

<img width="620" alt="설명그림" src="https://user-images.githubusercontent.com/77680436/118789290-999ee300-b8cf-11eb-8fcb-1f5605d30e69.png">

건설회사의 설계사인 `죠르디`는 고객사로부터 자동차 경주로 건설에 필요한 견적을 의뢰받았습니다.  
제공된 경주로 설계 도면에 따르면 경주로 부지는 `N x N` 크기의 정사각형 격자 형태이며 각 격자는 `1 x 1` 크기입니다.  
설계 도면에는 각 격자의 칸은 `0` 또는 `1` 로 채워져 있으며, `0`은 칸이 비어 있음을 `1`은 해당 칸이 벽으로 채워져 있음을 나타냅니다.  
경주로의 출발점은 (0, 0) 칸(좌측 상단)이며, 도착점은 (N-1, N-1) 칸(우측 하단)입니다. 죠르디는 출발점인 (0, 0) 칸에서 출발한 자동차가 도착점인 (N-1, N-1) 칸까지 무사히 도달할 수 있게 중간에 끊기지 않도록 경주로를 건설해야 합니다.  
경주로는 상, 하, 좌, 우로 인접한 두 빈 칸을 연결하여 건설할 수 있으며, 벽이 있는 칸에는 경주로를 건설할 수 없습니다.  
이때, 인접한 두 빈 칸을 상하 또는 좌우로 연결한 경주로를 `직선 도로` 라고 합니다.  
또한 두 `직선 도로`가 서로 직각으로 만나는 지점을 `코너` 라고 부릅니다.  
건설 비용을 계산해 보니 `직선 도로` 하나를 만들 때는 100원이 소요되며, `코너`를 하나 만들 때는 500원이 추가로 듭니다.  
죠르디는 견적서 작성을 위해 경주로를 건설하는 데 필요한 최소 비용을 계산해야 합니다.  

예를 들어, 아래 그림은 `직선 도로` 6개와 `코너` 4개로 구성된 임의의 경주로 예시이며, 건설 비용은 6 x 100 + 4 x 500 = 2600원 입니다.

<img width="420" alt="설명1" src="https://user-images.githubusercontent.com/77680436/118789993-4e390480-b8d0-11eb-8d6c-767252126815.png">

또 다른 예로, 아래 그림은 `직선 도로` 4개와 `코너` 1개로 구성된 경주로이며, 건설 비용은 4 x 100 + 1 x 500 = 900원 입니다.

<img width="420" alt="설명2" src="https://user-images.githubusercontent.com/77680436/118790493-c8698900-b8d0-11eb-8a7f-04344d60e2d9.png">

도면의 상태(0은 비어 있음, 1은 벽)을 나타내는 2차원 배열 board가 매개변수로 주어질 때, 경주로를 건설하는데 필요한 최소 비용을 return 하도록 solution 함수를 완성해주세요.

___

### [제한사항]
* board는 2차원 정사각 배열로 배열의 크기는 3 이상 25 이하입니다.
* board 배열의 각 원소의 값은 0 또는 1 입니다.
  * 도면의 가장 왼쪽 상단 좌표는 (0, 0)이며, 가장 우측 하단 좌표는 (N-1, N-1) 입니다.
  * 원소의 값 0은 칸이 비어 있어 도로 연결이 가능함을 1은 칸이 벽으로 채워져 있어 도로 연결이 불가능함을 나타냅니다.
* board는 항상 출발점에서 도착점까지 경주로를 건설할 수 있는 형태로 주어집니다.
* 출발점과 도착점 칸의 원소의 값은 항상 0으로 주어집니다.

___

### 입출력 예
|board|result|
|:---|:---|
|[[0,0,0],[0,0,0],[0,0,0]]|900|
|[[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,0],[0,0,0,0,1,0,0,0],[0,0,0,1,0,0,0,1],[0,0,1,0,0,0,1,0],[0,1,0,0,0,1,0,0],[1,0,0,0,0,0,0,0]]|3800|
|[[0,0,1,0],[0,0,0,0],[0,1,0,1],[1,0,0,0]]|2100|
|[[0,0,0,0,0,0],[0,1,1,1,1,0],[0,0,1,0,0,0],[1,0,0,1,0,1],[0,1,0,0,0,1],[0,0,0,0,0,0]]|3200|

### 입출력 예에 대한 설명
**입출력 예 #1**

본문의 예시와 같습니다.

**입출력 예 #2**

<img width="420" alt="예시1" src="https://user-images.githubusercontent.com/77680436/118790863-1e3e3100-b8d1-11eb-8937-aec7b083c92d.png">

위와 같이 경주로를 건설하면 `직선 도로` 18개, `코너` 4개로 총 3800원이 듭니다.

**입출력 예 #3**

<img width="420" alt="예시2" src="https://user-images.githubusercontent.com/77680436/118791001-3f9f1d00-b8d1-11eb-9eb0-84795422d2e9.png">

위와 같이 경주로를 건설하면 `직선 도로` 6개, `코너` 3개로 총 2100원이 듭니다.

**입출력 예 #4**

<img width="420" alt="예시3" src="https://user-images.githubusercontent.com/77680436/118791075-55acdd80-b8d1-11eb-8129-f601e059a214.png">

붉은색 경로와 같이 경주로를 건설하면 `직선 도로` 12개, `코너` 4개로 총 3200원이 듭니다.  
만약, 파란색 경로와 같이 경주로를 건설한다면 `직선 도로` 10개, `코너` 5개로 총 3500원이 들며, 더 많은 비용이 듭니다.

## 제출답안
```python
from collections import deque
def move(now, direction): # 상하좌우로 이동하는 함수
    if direction == 'up': return (now[0], now[1]-1)
    elif direction == 'down': return (now[0], now[1]+1)
    elif direction == 'left': return (now[0]-1, now[1])
    else: return (now[0]+1, now[1]) # right

def rangeCheck(now, maxMap): # 좌표가 도면을 내에 있는지 확인하는 함수
    return now[0] >= 0 and now[0] <= maxMap and now[1] >= 0 and now[1] <= maxMap

def bfs(start, board): # BFS를 수행하며 경주로를 건성하는 비용 측정
    queue = deque([(start, True, 0), (start, False, 0)]) # 세로 방향으로 출발하는 경우, 가로 방향으로 출발하는 경우
    dest = len(board) - 1
    costMap = [[999999]*len(board) for _ in range(len(board))] # 출발지에서 각 지점까지의 최소 비용을 저장
    costMap[0][0] = 0

    while queue:
        now, isUpDown, cost = queue.popleft()
        if cost > costMap[now[1]][now[0]]: continue # 큐에는 들어갔지만 최소로 이동하는 방법이 갱신된 경우 불필요한 계산 스킵
        for direction in ('up', 'down', 'left', 'right'):
            x, y = move(now, direction)
            _isUpDown = direction == 'up' or direction == 'down' # 움직이는 방향이 세로 방향인지 여부
            _cost = cost + (600 if isUpDown != _isUpDown else 100) # 바라보고 있던 방향과 움직이는 방향의 가로 세로가 다른지 판단하여 비용 측정
            if rangeCheck((x, y), dest) and not board[y][x] and costMap[y][x] >= _cost: # 해당 지점에 경주로를 건설할 수 있고, 기존보다 더 작은 비용이면 비용 수정 후 방문
                costMap[y][x] = _cost
                queue.append(((x, y), _isUpDown, _cost))

    return costMap[dest][dest]

def solution(board):
    return bfs((0, 0), board)
```
### 설명

**모든 테스트 케이스를 통과하였지만 반례가 존재하는 답안입니다. 정확한 답안은 개선사항을 확인해주시길 바랍니다.**

먼저 비용을 측정하는 방법(코너를 판단하는 방법)을 생각해보자.

이를 위해 카카오에서는 마지막으로 바라보는 방향을 저장하고 직진인지 좌, 우회전인지 판단하는 방법을 사용하였다.

본 답안에서는 비슷하지만 약간은 다른 방법을 사용했다. 여기에서는 바라보는 방향 대신에 마지막에 세로 방향으로 움직였는지 가로 방향으로 움직였는지 저장하였다.  

만약 세로 방향으로 움직였었는데 또 세로 방향으로 가거나 가로 방향으로 움직였었는데 또 가로 방향으로 간다면 이는 `직선 도로`가 될 것이다.  
반대로 직전은 세로 방향이었지만 다음엔 가로 방향으로 움직이거나 직전에 가로 방향이어지만 다음은 세로 방향으로 움직인다면 이는 `코너`가 될 것이다.

즉, 마지막으로 바라보는 방향 대신에 마지막으로 세로 방향(상 또는 하)이었는지를 저장해서 다음에 움직이는 방향이 같은 세로인지 아니면 가로(좌 또는 우)인지 판단하여 비교하는 방법으로 코너를 판단하였다.

다음으로는 본 문제를 풀기위한 탐색 방법을 생각해보자.  
본 문제의 경우 움직이는 비용이 모두 동일하지 않기 때문에 일반적인 BFS로는 풀 수 없다.

이러한 이유는 일반적인 BFS의 경우 한 번 방문한 곳은 해당 비용이 최소임이 보장되기 때문에(최소의 조작 횟수를 보장하며 모든 조작의 비용이 같기 때문에) 다시 방문하지 않지만, 
본 문제에서는 이미 방문했던 지점도 다른 경로로 온 경우가 최소가 될 수 있기 때문이다.

이는 입출력 예제 4번에서 보여주고 있다.(파란색 경로가 일반적인 BFS)

따라서 본 문제에서는 이미 방문한 지점을 조건적으로 다시 방문할 수 있으면서도 무한 루프를 방지할 수 있는 방안이 필요하다.

본 답안에서는 이를 위해 방문 여부를 나타냈던 `visited`와 같은 변수와 유사한 기능을 하면서 위의 조건을 만족할 수 있는 `costMap` 변수를 이용하였다.

`costMap`은 해당 지점을 방문했는지 여부가 아니라 해당 지점까지 가는(경주로를 건설하는) 최소 비용이 들어간다.

이렇게 `costMap`에 비용을 저장하고 해당 비용보다 큰 경우에는 방문하지 않도록 하면 위에서 말했듯이 무한 루프는 돌지 않으면서 조건적으로 재방문해 진짜 최솟값을 구할 수 있다.

또한 이 경우에는 여러 번 방문이 가능하므로 큐에 같은 지점이 여러 개 들어있을 수 있다. 따라서 큐에서 꺼낸 이후
```python
if cost > costMap[now[1]][now[0]]: continue
```
위와 같이 `costMap`이 갱신되기 전에 들어간 값인지 확인하여 불필요한 연산을 하지 않도록 차단하면서 더 최적화시킬 수 있다.

이렇게 BFS를 수행하고 `costMap`의 도착지 부분의 값(`costMap[dest][dest]`)을 확인하면 해당 지점까지 경주로를 건설하는 최소 비용이 들어있으므로 이는 답이 된다.

**모든 테스트 케이스를 통과하였지만 반례가 존재하는 답안입니다. 정확한 답안은 개선사항을 확인해주시길 바랍니다.**

## 개선사항
본 문제를 풀 당시에는 테스트 케이스를 모두 통과하였기 때문에 별 생각없이 넘어갔던 문제이다. 하지만 유심히 살펴보니 약간 이해가 되지 않는 부분들이 있어 반례를 찾아보니 반례가 나오는 코드였다.

위의 코드는 다음과 같은 경우에 반례가 생길 수 있다.

`해당 지점까지 이동하는 비용은 최소가 아니지만 다음에 움직이는 지점은 최소가 되는 경로`  
즉, 해당 지점을 (i, j)지점이라고 하고 다음에 움직일 지점을 (i, j+1) 지점이라고 해보자. 이때 `costMap[i][j]`에 1000이 들어가있으며 세로 방향으로 도착하였다.  
그런데 (i, j) 까지 1200으로 도착하는 `newCost[i][j]`가 있으며 이는 가로 방향으로 도착하였다. 하지만 기존에 1000으로 방문하는 경로가 있어 방문하지 않는다.

(i, j+1) 지점은 (i, j) 지점에서 가로 방향으로 움직이는 지점이라고 하자. 
그러면 (i, j+1)까지의 최소 비용은 어떻게 될까. 답안의 경우에는 (i, j)까지 오는 최소인 1000에서 코너를 돌아 1600이 되는 식으로 동작한다. 
하지만 실제로는 1200 비용에서 직진하는 1300이 진짜 최소가 된다.

즉, 다음과 같은 경우가 생기는 것이다.  
`costMap[i][j] + 600  > newCost[i][j] + 100, 단 costMap[i][j] < newCost[i][j]`

예시를 살펴보자. `board`는 다음과 같다.

[0, 0, 0, 1, 1]  
[0, 1, 0, 0, 1]  
[0, 1, 1, 0, 1]  
[0, 1, 0, 0, <b><ins>0</ins></b>]  
[0, 0, 0, 1, 0]

여기서 밑줄 친 지점의 비용을 생각해보자.
먼저 출발할 때 오른쪽 길로가는 경로를 생각해보자 그럴 경우 밑줄 직전까지의 비용은 다음과 같다.

```
[0,   100,  200, 1,    1]  
[0,   1,    800, 1400, 1]  
[0,   1,    1,   2000, 1]  
[0,   1,    0,   2100, 0]  
[0,   0,    0,   1,    0]

직전: 세로 방향, 2100 비용
```

이번에는 출발할 때 아래 방향으로 가는 경로를 생각해보자.

```
[0,   0,    0,    1,    1]  
[100, 1,    0,    0,    1]  
[200, 1,    1,    0,    1]  
[300, 1,    1700, 2300, 0]  
[400, 1000, 1100, 1,    0]

직전: 가로 방향, 2300 비용
```

예를 보면 밑줄 지점 직전인 곳은 최소가 2100이다. 따라서 2300인 경로는 방문하지 않는다. 그렇다면 원래 의도에 따르면 2100인 경로에서 밑줄 지점에 건설하는 것이 최소가 되어야 한다.  
하지만 실제로는 아래의 2300인 경로가 밑줄 지점과 방향이 같기 때문에 최소가 된다.(2100 + 600 > 2300 + 100)

이처럼 본 답안에서는 반례가 존재하는 것을 확인하였다. 그렇다면 어떻게 정확한 답안으로 수정할 수 있을까?  
반례를 살펴보면 마지막 방향에 따라서 실제 최소가 의도와는 다르게 되었다. 그러므로 마지막에 방향에 따라 최솟값을 저장하고 그 중 최소를 반환하도록 수정할 수 있다. 
즉 세로 방향으로 도착하는 경우의 최솟값과 가로 방향으로 도착하는 경우의 최솟값을 따로 저장하여 각자에 맞게 비교하는 방법이다.

이렇게 한다면 위의 반례에서 2100으로 방문하는 경우와 2300으로 방문하는 경우는 각각 방문하는 방향이 다르므로 모두 방문할 수 있다. 따라서 밑줄 지점의 최솟값 역시 2400이 저장될 수 있는 것이다.  
(costMap의 각 값으로는 [가로방향으로 도착하는 최솟값, 세로방향으로 도착하는 최솟값]이 저장되며 출발지에서 각 지점까지의 최소 비용은 `min(costMap[i][j])`로 계산한다.)

이에 맞게 코드를 수정하면 다음과 같다.
```python
def bfs(start, board):
    queue = deque([(start, True, 0), (start, False, 0)])
    dest = len(board) - 1
    costMap = [[[999999, 999999] for _ in range(len(board))] for _ in range(len(board))]
    costMap[0][0] = [0, 0] # [가로방향으로 도착하는 최솟값, 세로방향으로 도착하는 최솟값]

    while queue:
        now, isUpDown, cost = queue.popleft()
        if cost > costMap[now[1]][now[0]][isUpDown]: continue
        for direction in ('up', 'down', 'left', 'right'):
            x, y = move(now, direction)
            _isUpDown = direction == 'up' or direction == 'down'
            _cost = cost + (600 if isUpDown != _isUpDown else 100)
            if rangeCheck((x, y), dest) and not board[y][x] and costMap[y][x][_isUpDown] > _cost:
                costMap[y][x][_isUpDown] = _cost
                queue.append(((x, y), _isUpDown, _cost))

    return min(costMap[dest][dest])
```

정확성에 대한 개선을 하였으니 이번에는 효율성에 대한 개선을 해보자. 

위에서는 BFS(Breadth First Search)를 이용하여 문제를 해결하였다. 이는 오로지 다음 선택이 큐에 들어온 순서에 의하여 결정되므로 어떤 면에서 맹목적이다.

알고리즘을 배워본 사람이라면 분기한정법을 배워봤을 것이다. 분기한정법은 다음 선택을 단순히 들어온 순서가 아니라 우선순위에 따라 결정한다. 
쉽게 말해 답이 될 가능성이 높은 것부터 방문한다는 것이다. 이렇게 한다면 확률적으로 더 빠르게 답을 구하고 불필요한 계산을 하지 않을 확률이 높다.

이를 본 문제에서도 적용할 수 있다. 힙(우선순위 큐)을 이용하여 비용이 낮은 것부터 처리한다면 답이 될 가능성이 높은 경로를 우선 탐색하게 될 것이다.  
(이를 BFS(Best First Search)라고도 하는 것으로 기억한다. ~~헷갈리게 둘 다 BFS다~~)

효율성 개선을 적용하면 다음과 같다.
```python
import heapq
def bfs(start, board):
    heap = [(0, start, True), (0, start, False)]
    dest = len(board) - 1
    costMap = [[[999999, 999999] for _ in range(len(board))] for _ in range(len(board))]
    costMap[0][0] = [0, 0]

    while heap:
        cost, now, isUpDown = heapq.heappop(heap)
        if cost > costMap[now[1]][now[0]][isUpDown]: continue
        for direction in ('up', 'down', 'left', 'right'):
            x, y = move(now, direction)
            _isUpDown = direction == 'up' or direction == 'down'
            _cost = cost + (600 if isUpDown != _isUpDown else 100)
            if rangeCheck((x, y), dest) and not board[y][x] and costMap[y][x][_isUpDown] > _cost:
                costMap[y][x][_isUpDown] = _cost
                heapq.heappush(heap, (_cost, (x, y), _isUpDown))

    return min(costMap[dest][dest])
```

실제로 board를 문제의 제한사항 범위 이내에서 랜덤으로 생성하고 큐를 이용한 bfs와 힙을 이용한 bfs를 비교하여 실험해보았다.
총 300,000 번 맵을 랜덤으로 생성하고 각각 탐색을 수행한 결과 힙을 이용한 경우가 더 빠른 횟수가 284,800번, 큐를 이용한 경우가 더 빠른 횟수가 15,200번으로 확연히 힙이 빠른 경우가 많은 것을 볼 수 있었다. 
또한 while문 반복 횟수 역시 힙을 이용한 경우가 더 적은 횟수가 299,300번, 큐를 이용한 경우가 더 적은 횟수가 700번으로 마찬가지로 차이를 보였다.
