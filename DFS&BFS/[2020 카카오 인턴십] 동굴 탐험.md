# [2020 카카오 인턴십] 동굴 탐험
## 문제
### 문제 설명
([원본 문제](https://programmers.co.kr/learn/courses/30/lessons/67260)의 내용을 복사한 것입니다.)

<img width="620" alt="설명그림" src="https://user-images.githubusercontent.com/77680436/117537067-abfc5f80-b039-11eb-90d8-5a814477ab99.png">

오지 탐험가인 `프로도`는 탐험 도중 n개의 방으로 이루어진 지하 동굴을 탐험하게 되었습니다. 모든 방에는 0부터 n - 1 까지 번호가 붙어있고, 이 동굴에 들어갈 수 있는 유일한 입구는 0번 방과 연결되어 있습니다. 각 방들은 양방향으로 통행이 가능한 통로로 서로 연결되어 있는데, 서로 다른 두 방을 직접 연결하는 통로는 오직 하나입니다. 임의의 서로 다른 두 방 사이의 최단경로는 딱 한 가지만 있으며, 또한 임의의 두 방 사이에 이동이 불가능한 경우는 없습니다.

탐험에 앞서 이 지하 동굴의 지도를 손에 넣은 프로도는 다음과 같이 탐험 계획을 세웠습니다.

1. 모든 방을 적어도 한 번은 방문해야 합니다.
2. 특정 방은 방문하기 전에 반드시 먼저 방문할 방이 정해져 있습니다.  
  2-1. 이는 A번 방은 방문하기 전에 반드시 B번 방을 먼저 방문해야 한다는 의미입니다.  
  2-2. 어떤 방을 방문하기 위해 반드시 먼저 방문해야 하는 방은 없거나 또는 1개 입니다.  
  2-3. 서로 다른 두 개 이상의 방에 대해 먼저 방문해야 하는 방이 같은 경우는 없습니다.  
  2-4. 어떤 방이 먼저 방문해야 하는 방이면서 동시에 나중에 방문해야 되는 방인 경우는 없습니다.
  
위 계획 중 2-2, 2-3, 2-4는 순서를 지켜 방문해야 하는 두 방의 쌍이 `A → B`(A를 먼저 방문하고 B를 방문함) 형태로 유일함을 의미합니다. 즉, 프로도는 아래와 같은 형태로 방문순서가 잡히지 않도록 방문 계획을 세웠습니다.

* `A → B, A → C` (방문순서 배열 order = [...,[A,B],...,[A,C],...]) 형태로 A를 방문 후에 방문해야 할 방이 B와 C로 두 개 또는 그 이상인 경우
* `X → A, Z → A` (방문순서 배열 order = [...,[X,A],...,[Z,A],...]) 형태로 A를 방문하기 전에 방문해야 할 방이 X와 Z로 두 개 또는 그 이상인 경우
* `A → B → C` (방문순서 배열 order = [...,[A,B],...,[B,C],...) 형태로 B처럼 A 방문 후이면서 동시에 C 방문 전인 경우

그리고 먼저 방문해야 할 방과 나중에 방문할 방을 반드시 연속해서 방문해야 할 필요는 없어 A방을 방문한 후 다른 방을 방문한 후 B방을 방문해도 좋습니다.

방 개수 n, 동굴의 각 통로들이 연결하는 두 방의 번호가 담긴 2차원 배열 path, 프로도가 정한 방문 순서가 담긴 2차원 배열 order가 매개변수로 주어질 때, 프로도가 규칙에 맞게 모든 방을 탐험할 수 있을 지 return 하도록 solution 함수를 완성해주세요.

### [제한사항]
* n은 2 이상 200,000 이하입니다.
* path 배열의 세로(행) 길이는 n - 1 입니다.
  * path 배열의 원소는 [방 번호 A, 방 번호 B] 형태입니다.
  * 두 방 A, B사이를 연결하는 통로를 나타냅니다.
  * 통로가 연결하는 두 방 번호가 순서없이 들어있음에 주의하세요.
* order 배열의 세로(행) 길이는 1 이상 (n / 2) 이하입니다.
  * order 배열의 원소는 [방 번호 A, 방 번호 B] 형태입니다.
  * A번 방을 먼저 방문한 후 B번 방을 방문해야 함을 나타냅니다.

___

### 입출력 예
|n|path|order|result|
|:---|:---|:---|:---|
|9|[[0,1],[0,3],[0,7],[8,1],[3,6],[1,2],[4,7],[7,5]]|[[8,5],[6,7],[4,1]]|true|
|9|[[8,1],[0,1],[1,2],[0,7],[4,7],[0,3],[7,5],[3,6]]|[[4,1],[5,2]]|true|
|9|[[0,1],[0,3],[0,7],[8,1],[3,6],[1,2],[4,7],[7,5]]|[[4,1],[8,7],[6,5]]|false|

### 입출력 예에 대한 설명
**입출력 예 #1**

동굴 그림은 아래와 같습니다.

<img width="420" alt="예시1" src="https://user-images.githubusercontent.com/77680436/117537190-6a1fe900-b03a-11eb-818b-bd0cc9c622a7.png">

방문 순서를 지켜야 하는 방 번호는 다음과 같습니다.

* 6번 → 7번
* 4번 → 1번
* 8번 → 5번

따라서 모든 방을 방문할 수 있는 방법 중 하나는 다음과 같습니다.

* 0번 → 3번 → 6번 → 3번 → 0번 → 7번 → 4번 → 7번 → 0번 → 1번 → 8번 → 1번 → 2번 → 1번 → 0번 → 7번 → 5번

**입출력 예 #2**

<img width="420" alt="예시2" src="https://user-images.githubusercontent.com/77680436/117537232-976c9700-b03a-11eb-833d-2fd803894f25.png">

다음 순서로 각 방을 방문하면 됩니다.

* 0번 → 7번 → 4번 → 7번 → 5번 → 7번 → 0번 → 3번 → 6번 → 3번 → 0번 → 1번 → 8번 → 1번 → 2번

**입출력 예 #3**

<img width="420" alt="예시3" src="https://user-images.githubusercontent.com/77680436/117537253-aeab8480-b03a-11eb-8621-4ee35b3d4eb6.png">

규칙에 맞게 모든 방을 방문할 수 있는 방법이 없습니다.

## 제출답안
```python
from collections import deque
def bfs(path, before, after):
    queue = deque([0])
    visited = set() # 방문했던 방의 정보를 저장

    while True:
        l = len(after) # 현재 선행 조건을 만족하지 못한 후행 방의 수 저장
        again = deque() # BFS가 끝나고 다시 방문할 방들

        while queue:
            node = queue.popleft()
            if node in after: continue # 현재 방문한 방이 선행 조건을 아직 만족하지 못 했으면 돌아감

            for n in path[node]: # 현재 방과 연결된 방들
                if n not in visited: # 아직 방문하지 않았으면 방문(양방향 연결 통로지만 0번을 루트로 하는 트리 형태일 때 자식만 방문하게 됨)
                    visited.add(n)
                    queue.append(n)
                    if n in before: # 현재 방문하는 방이 어딘가의 선행 방일 때
                        if before[n] in visited: again.append(before[n]) # 현재 방의 후행 방을 이미 방문했다 돌아온 적이 있다면 재방문 목록에 추가
                        after.remove(before[n]) # 선행 조건을 만족하지 못한 방 목록에서 현재 방의 후행이 되는 방 제거

        if not after: return True # 선행 조건을 모두 만족했다면 어차피 모든 방을 방문할 수 있음
        if l == len(after): return False # 이번 BFS에서 추가로 선행 조건을 만족한 방이 하나도 없을 때, 즉 더 이상 진행 불가
        queue = again # 재방문 방 목록이 담긴 큐를 이용하여 다시 BFS를 통해 해당 방부터 방문

def solution(n, path, order):
    before, after = dict(), set() # before = {선행 방: 후행 방} 쌍, after = 후행 방, 즉 선행 조건을 아직 만족하지 못해 방문할 수 없는 방

    for b, a in order: # 선, 후행 방에 대한 정보 저장
        after.add(a)
        before[b] = a

    _path = dict()
    for p in path: # 연결 정보를 접근하기 쉽게 해시 테이블 형태로 저장({방: 방에 연결된 다른 방 번호들})
        if p[0] in _path: _path[p[0]].append(p[1])
        else: _path[p[0]] = [p[1]]
        if p[1] in _path: _path[p[1]].append(p[0])
        else: _path[p[1]] = [p[0]]

    return bfs(_path, before, after)
```
### 설명
본 문제의 경우 다양한 풀이가 존재할 수 있는데, 먼저 카카오에서는 주어진 정보를 이용하여 방향그래프를 만들고 그래프에 사이클이 존재하는지 확인하는 방법을 사용하였다. 
이에 대한 자세한 내용은 [카카오 공식 블로그](https://tech.kakao.com/2020/07/01/2020-internship-test/)의 풀이를 참조하길 바란다.

본 풀이에서는 BFS를 이용하여 문제를 해결하였다.  
문제 해결 아이디어는 간단하다. 선행 조건을 만족해야할 방들의 목록을 만들고 BFS를 반복적으로 진행하면서 선행 방을 만나면 해당 목록을 지워나가는 것이다.

전체적인 알고리즘은 다음과 같다.

```
1. '선행 조건을 만족해야 할 방 목록' 저장
2. BFS를 통해 순차적으로 방들을 방문  
  2-1. 현재 방문한 방이 선, 후행에 상관이 없는 방이라면 그냥 방문  
  2-2. 현재 방문한 방이 아직 선행 조건을 만족하지 않아 방문할 수 없는 방이라면 다음 방을 방문하지 않고 돌아옴  
  2-3. 현재 방문한 방이 어딘가의 선행이 되는 방이라면 '선행 조건을 만족해야 할 방 목록'에서 현재 방의 후행이 되는 방 제거  
    2-3-1. 만약 현재 방의 후행 방을 이미 방문했다가 돌아온 적이 있다면 해당 방을 '다시 방문할 방 목록'에 저장
3. BFS가 끝난 이후 '선행 조건을 만족해야 할 방 목록'이 비어있다면, 모든 방을 방문할 수 있다는 의미이므로 True 반환  
4. BFS가 끝난 이후 '선행 조건을 만족해야 할 방 목록'이 남아있다면,  
  4-1. BFS를 진행 후 '선행 조건을 만족해야 할 방 목록'에서 추가로 지워진 방이 없다면 더 이상 탐험을 진행할 수 없다는 것이므로 False 반환  
  4-2. BFS를 진행 후 '선행 조건을 만족해야 할 방 목록'에서 추가로 지워진 방이 있다면 '다시 방문할 방 목록'에 있는 방부터 다시 2번 과정 수행
```

위의 알고리즘을 이용한다면 BFS만을 이용하여 본 문제를 해결할 수 있으며, 이에 따라 구현한 것이 제출답안과 같다.
