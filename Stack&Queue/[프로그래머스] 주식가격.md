# [프로그래머스] 주식가격
## 문제
### 문제 설명
([원본 문제](https://programmers.co.kr/learn/courses/30/lessons/42584)의 내용을 복사한 것입니다.)

초 단위로 기록된 주식가격이 담긴 배열 prices가 매개변수로 주어질 때, 가격이 떨어지지 않은 기간은 몇 초인지를 return 하도록 solution 함수를 완성하세요.

### 제한사항
* prices의 각 가격은 1 이상 10,000 이하인 자연수입니다.
* prices의 길이는 2 이상 100,000 이하입니다.

### 입출력 예
|prices|return|
|:---:|:---:|
|[1, 2, 3, 2, 3]|[4, 3, 1, 1, 0]|

### 입출력 예 설명
* 1초 시점의 ₩1은 끝까지 가격이 떨어지지 않았습니다.
* 2초 시점의 ₩2은 끝까지 가격이 떨어지지 않았습니다.
* 3초 시점의 ₩3은 1초뒤에 가격이 떨어집니다. 따라서 1초간 가격이 떨어지지 않은 것으로 봅니다.
* 4초 시점의 ₩2은 1초간 가격이 떨어지지 않았습니다.
* 5초 시점의 ₩3은 0초간 가격이 떨어지지 않았습니다.

## 제출답안
```python
def solution(prices):
    answer = []
    for i in range(len(prices)):
        for j in range(i+1, len(prices)):
            if prices[i] > prices[j]: # i+1초부터 가격이 떨어지는 시점 j를 찾는다.
                break
        answer.append(j - i) # 가격이 유지된 시간을 정답 리스트에 추가한다.
    return answer
```
### 설명
사실 본 문제의 경우 분류가 스택/큐로 되어있어 이를 이용하여 풀어야 문제에서 의도한 답일 것이다. 나 또한 반복문으로 풀면 너무나도 간단한 문제이지만 스택이나 큐를 이용하려고 
고민을 많이 했다. 하지만 잘 생각이 나지 않아, 어차피 스택이나 큐를 이용한 게 아니면 시간초과가 나겠지 하면서 제출해본건데 통과해버렸다.. 하지만 그래도 내가 제출한 코드를 솔직하게 
올려놓고 설명을 하는 것이 맞다고 생각하여 그대로 올린다.

제출답안은 쉽게 이해할 수 있을 정도로 간단하다. 이중 for문을 돌리며 i와 i 이후의 시간들을 비교해 가격을 유지한 시간을 리스트에 추가한다. 이를 prices의 모든 원소에 대해 반복한다.

## 개선사항
답안을 제출 후 원래의 의도대로 스택을 이용하여 푸는 방법을 검색해보았더니, 약간의 차이는 있지만 대부분 아래와 같은 형태였다.
```python
# 스택을 이용한 풀이
def solution(prices):
    answer = [0] * len(prices)
    stack = [] # 아직 가격이 떨어지지 않은 시간(초)
    for i in range(len(prices)): # 스택에 있는 시간의 가격들이 i초에서 떨어졌는지 확인
        while stack and prices[stack[-1]] > prices[i]:
            temp = stack.pop()
            answer[temp] = i - temp
        stack.append(i)
    
    while stack: # 끝까지 떨어지지 않은 시간대에 대한 처리
        temp = stack.pop()
        answer[temp] = len(prices) - temp - 1
    
    return answer
```
문제를 풀기 위한 핵심 아이디어는 **"스택에 시간을 저장하자"** 였다. 위에서 stack에는 아직 가격이 떨어지지 않은 시간(초)를 저장한다.  
입출력 예를 통해 위의 진행을 살펴보면 다음과 같다.(입력: [1, 2, 3, 2, 3], 이해하기 쉽게 하기 위해 원래는 i가 0부터이지만 여기서는 1부터로 나타내었다.)

* for문

|i|i초의 가격|stack|answer|
|:---:|:---:|:---:|:---:|
|1|[<ins>1</ins>, 2, 3, 2, 3]|[]|[0, 0, 0, 0, 0]|
|2|[1, <ins>2</ins>, 3, 2, 3]|[1]|[0, 0, 0, 0, 0]|
|3|[1, 2, <ins>3</ins>, 2, 3]|[1, 2]|[0, 0, 0, 0, 0]|
|4|[1, 2, 3, <ins>2</ins>, 3]|[1, 2, 3]|[0, 0, 0, 0, 0]|
|5|[1, 2, 3, 2, <ins>3</ins>]|[1, 2, 4]|[0, 0, 1, 0, 0]|
|for문 이후|[1, 2, 3, 2, 3]|[1, 2, 4, 5]|[0, 0, 1, 0, 0]|

* while문

for문을 다 돌고나면 stack에는 끌까지 가격이 떨어지지 않은 시간만이 남아있다. 따라서 스택에서 하나씩 꺼내어 해당 시간이 끝 시간으로부터 얼마나 차이나는지 정답 리스트에 기록하면 답이 
된다.

</br>  
  
스택을 이용한 풀이를 보면 이 역시 for 안에 while이 있는 중첩 반복문임은 제출답안과 크게 다르지 않다. 하지만 스택을 이용했을 때의 장점이 존재하는데, 
이는 스택에 나중에 쌓인 값은 항상 스택에 먼저 쌓인 값들보다 크거나 같다는 성질 때문이다.

예를 들어 for문 이후의 스택을 보자. 스택에는 [1, 2, 4, 5] 시간이 쌓여있다. 
이를 가격과 함께 표시해보면 [1(1), 2(2), 4(2), 5(3)]이다. 여기서 5초의 가격 3은 그 이전에 쌓인 가격들보다 항상 크거나 같다. 따라서 다음 6초에 새로운 가격이 있고, 해당 가격이 5초의 가격 3보다 크거나 같다면 결국 그 이전에 쌓인 시간의 가격들보다는 자연스럽게 크거나 같기 때문에 굳이 비교하지 않아도 된다. 이처럼 스택을 이용한다면 비교횟수를 크게 줄일 수 있기 때문에 시간복잡도 측면에서 이득을 볼 수 있다.
