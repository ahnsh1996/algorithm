# [2019 카카오 개발자 겨울 인턴십] 튜플
## 문제
### 문제 설명
([원본 문제](https://programmers.co.kr/learn/courses/30/lessons/64065)의 내용을 복사한 것입니다.)

셀수있는 수량의 순서있는 열거 또는 어떤 순서를 따르는 요소들의 모음을 튜플(tuple)이라고 합니다. n개의 요소를 가진 튜플을 n-튜플(n-tuple)이라고 하며, 다음과 같이 표현할 수 있습니다.

* (a1, a2, a3, ..., an)

튜플은 다음과 같은 성질을 가지고 있습니다.

1. 중복된 원소가 있을 수 있습니다. ex : (2, 3, 1, 2)
2. 원소에 정해진 순서가 있으며, 원소의 순서가 다르면 서로 다른 튜플입니다. ex : (1, 2, 3) ≠ (1, 3, 2)
3. 튜플의 원소 개수는 유한합니다.

원소의 개수가 n개이고, <ins><b>중복되는 원소가 없는</b></ins> 튜플 ```(a1, a2, a3, ..., an)```이 주어질 때(단, a1, a2, ..., an은 자연수), 이는 다음과 같이 집합 기호 '{', '}'를 이용해 표현할 수 있습니다.

* {{a1}, {a1, a2}, {a1, a2, a3}, {a1, a2, a3, a4}, ... {a1, a2, a3, a4, ..., an}}

예를 들어 튜플이 (2, 1, 3, 4)인 경우 이는

* {{2}, {2, 1}, {2, 1, 3}, {2, 1, 3, 4}}

와 같이 표현할 수 있습니다. 이때, 집합은 원소의 순서가 바뀌어도 상관없으므로

* {{2}, {2, 1}, {2, 1, 3}, {2, 1, 3, 4}}
* {{2, 1, 3, 4}, {2}, {2, 1, 3}, {2, 1}}
* {{1, 2, 3}, {2, 1}, {1, 2, 4, 3}, {2}}

는 모두 같은 튜플 (2, 1, 3, 4)를 나타냅니다.

특정 튜플을 표현하는 집합이 담긴 문자열 s가 매개변수로 주어질 때, s가 표현하는 튜플을 배열에 담아 return 하도록 solution 함수를 완성해주세요.

### 제한사항
* s의 길이는 5 이상 1,000,000 이하입니다.
* s는 숫자와 '{', '}', ',' 로만 이루어져 있습니다.
* 숫자가 0으로 시작하는 경우는 없습니다.
* s는 항상 중복되는 원소가 없는 튜플을 올바르게 표현하고 있습니다.
* s가 표현하는 튜플의 원소는 1 이상 100,000 이하인 자연수입니다.
* return 하는 배열의 길이가 1 이상 500 이하인 경우만 입력으로 주어집니다.

### 입출력 예
|s|result|
|:---|:---|
|"{{2},{2,1},{2,1,3},{2,1,3,4}}"|[2, 1, 3, 4]|
|"{{1,2,3},{2,1},{1,2,4,3},{2}}"|[2, 1, 3, 4]|
|"{{20,111},{111}}"|[111, 20]|
|"{{123}}"|[123]|
|"{{4,2,3},{3},{2,3,4,1},{2,3}}"|[3, 2, 4, 1]|

### 입출력 예에 대한 설명
**입출력 예 #1**

문제 예시와 같습니다.

**입출력 예 #2**

문제 예시와 같습니다.

**입출력 예 #3**

(111, 20)을 집합 기호를 이용해 표현하면 {{111}, {111,20}}이 되며, 이는 {{20,111},{111}}과 같습니다.

**입출력 예 #4**

(123)을 집합 기호를 이용해 표현하면 {{123}} 입니다.

**입출력 예 #5**

(3, 2, 4, 1)을 집합 기호를 이용해 표현하면 {{3},{3,2},{3,2,4},{3,2,4,1}}이 되며, 이는 {{4,2,3},{3},{2,3,4,1},{2,3}}과 같습니다.

## 제출답안
```python
def solution(s):
    answer = [] # s가 표현하는 튜플(정답)
    temp = set() # in 연산의 시간 복잡도가 리스트보다 집합이 더 낮음을 이용하기 위함
    
    for element in sorted(s[2:-2].split('},{'), key=lambda x: len(x)): # 각 집합의 원소 수에 따라 오름차순 정렬
        for e in element.split(','): # 원소 안의 원소들을 하나씩 확인
            if e not in temp: # 원소 안의 원소가 이미 나왔던 적이 없는 원소면 추가
                answer.append(int(e))
                temp.add(e)
    
    return answer
```
### 설명
사실 본 문제의 경우 구현을 하는 것보다 문제를 이해하는 것이 더 헷갈릴 수 있을 것 같다.

문제에서는 중복되는 원소가 없는 튜플 ```(a1, a2, a3, ..., an)```이 주어질 때, 이를

* {{a1}, {a1, a2}, {a1, a2, a3}, {a1, a2, a3, a4}, ... {a1, a2, a3, a4, ..., an}}

과 같이 표현할 수 있다고 했다. 여기서 갑자기 순서가 중요한 튜플이 나오다 갑자기 순서가 상관 없는 집합이 나오니 헷갈릴 수 있다.

집합의 경우 순서가 상관없어 어떻게 튜플을 유추할 수 있을까 싶지만, 여기서 순서가 중요한 튜플을 설명했던 이유가 있다. 
이는 집합의 크기에 따라 튜플에서 올 수 있는 원소가 다르기 때문이다.

즉, 이는 다음을 의미한다.  
집합의 크기가 1인 ```{a1}```의 경우 원소로 튜플의 a1, 다시 말해 첫 번째 원소만이 가능하다.  
집합의 크기가 2인 ```{a1, a2}```의 경우 원소로 튜플의 a1과 a2, 다시 말해 첫 번째와 두 번째 원소만이 가능하다. 
이는 ```{a1, a2} = {a2, a1}```임과는 별개이다.

위와 같이 집합의 크기에 따라 튜플의 원소가 몇 번째까지 포함될 수 있는지가 달라진다.  
따라서 본 문제의 경우 집합의 크기를 기준으로 정렬을 하여 쉽게 풀 수 있다.

먼저 주어진 문자열을 파싱하기 위하여 처음과 끝의 "{{"과 "}}"을 잘라내고 나머지를 "},{"를 기준으로 분리한다.  
예를 들면, ```"{{1,2,3},{2,1},{1,2,4,3},{2}}"```의 경우 ```"1,2,3", "2,1", "1,2,4,3", "2"```가 될 것이다.

이제 이를 문자열의 길이를 기준으로 정렬한다.(집합의 크기를 기준으로 정렬)  
그 결과 ```"2", "2,1", "1,2,3", "1,2,4,3"```가 된다. 이제 이를 하나씩 가져와 새롭게 추가되는 원소가 무엇인지 확인하여 정답에 추가하면 된다.

1. 처음 {2}에서 올 수 있는 원소는 a1 뿐이다. 따라서 <b>a1은 2</b>이다.
2. 다음 {2, 1}에서 올 수 있는 원소는 a1과 a2이다. 중복이 없고 a1은 2이므로 <b>a2는 1</b>이다.
3. 다음 {1, 2, 3}에서 올 수 있는 원소는 a1, a2, 그리고 a3이다. 중복이 없고 a1은 2, a2는 1이므로 <b>a3는 3</b>이다.
4. 다음 {1, 2, 4, 3}에서 올 수 있는 원소는 a1, a2, a3, 그리고 a4이다. 중복이 없고 a1은 2, a2는 1, a3는 3이므로 <b>a4는 4</b>이다.

위와 같은 과정으로 정답을 찾을 수 있고, 이를 코드로 구현한 것이 제출 답안이다.  
답안에서 answer만으로도 구현이 가능하지만 집합 자료형인 temp를 사용하여준 이유는 리스트의 경우 in 연산이 O(n)이지만, 집합은 평균적으로 O(1)이기 때문이다.

실제로 리스트인 answer만으로 다음과 같이 구현하여 제출하여 비교해보면 차이가 많이 나는 것을 알 수 있다.
```python
# 리스트만으로 풀이

def solution(s):
    answer = []
    
    for element in sorted(s[2:-2].split('},{'), key=lambda x: len(x)):
        for e in element.split(','):
            if int(e) not in answer:
                answer.append(int(e))
    
    return answer
```

|제출 답안|리스트 풀이|
|:---:|:---:|
|![제출답안](https://user-images.githubusercontent.com/77680436/111302445-c39d1480-8696-11eb-8475-8b864233725e.png)|![리스트 풀이](https://user-images.githubusercontent.com/77680436/111302542-e0d1e300-8696-11eb-91d8-d6c5e5a5167c.png)|

## 개선사항
알고리즘적으로 개선할 점은 아니지만 항상 길이를 기준으로 정렬할 때, key로 ```lambda x: len(x)```를 이용하였다. 
하지만 내장함수 len을 바로 넣는 것도 가능하다는 것을 알게 되었다. 즉 다음과 같이 수정하면 조금 더 깔끔하게 표현될 것이다.
sorted(s[2:-2].split('},{'), key=lambda x: len(x)) → sorted(s[2:-2].split('},{'), key=len)
