# [프로그래머스] 가장 큰 수
## 문제
### 문제 설명
([원본 문제](https://programmers.co.kr/learn/courses/30/lessons/42746)의 내용을 복사한 것입니다.)

0 또는 양의 정수가 주어졌을 때, 정수를 이어 붙여 만들 수 있는 가장 큰 수를 알아내 주세요.

예를 들어, 주어진 정수가 [6, 10, 2]라면 [6102, 6210, 1062, 1026, 2610, 2106]를 만들 수 있고, 이중 가장 큰 수는 6210입니다.

0 또는 양의 정수가 담긴 배열 numbers가 매개변수로 주어질 때, 순서를 재배치하여 만들 수 있는 가장 큰 수를 문자열로 바꾸어 return 하도록 solution 함수를 작성해주세요.

### 제한사항
* numbers의 길이는 1 이상 100,000 이하입니다.
* numbers의 원소는 0 이상 1,000 이하입니다.
* 정답이 너무 클 수 있으니 문자열로 바꾸어 return 합니다.

### 입출력 예
|numbers|return|
|:---|:---|
|[6, 10, 2]|6210|
|[3, 30, 34, 5, 9]|9534330|

## 제출답안
```python
from functools import cmp_to_key
def compare(n1, n2): # 순서를 바꿔가며 붙여보고 대소 비교
    if n1 + n2 < n2 + n1: return 1
    elif n1 + n2 > n2 + n1: return -1
    else: return 0

def solution(numbers):
    if not any(numbers): return '0' # [0, 0, 0] 과 같은 입력이 주어졌을 때, '000'이 아닌 '0'을 반환하기 위함
    return ''.join(sorted(map(str, numbers), key=cmp_to_key(compare)))
```
### 설명
숫자의 대소비교에 있어 우선순위는 다음과 같다.

* 자리수가 많으면 더 큰 수이다.
* 같은 자리수라면 앞자리가 더 커야 더 큰 수이다.

자리수가 많기 위해서는 먼저 가장 앞 자리에 0이 오지 않아야 한다.(00123은 123으로 자리수가 줄어든다.)
나머지의 경우는 자리수는 어차피 같기 때문에 앞자리를 크게 만들어 주어야 한다.

앞자리를 크게 만들기 위해서는 여러 가지 신경 써주어야 할 것이 많다.

1. 실제 숫자가 크다고 무조건 먼저 오는 것이 큰 수를 만드는 것은 아니다.  
ex) [9, 98]의 경우 998이 989보다 크다.
2. 숫자의 앞부분은 같지만 마지막이 반복될 때, 경우에 따라 큰 수를 만드는 것이 다르다.  
ex) [34, 344]의 경우 34434가 더 큰 수가 되지만, [43, 433]의 경우 43343이 더 작은 수가 된다.

이처럼 고려해 주어야 할 것들이 많은데, 처음에는 이를 직접 구현하다가 더 간단한 방법이 떠올랐다.  
일단 직접 붙여보고 비교하는 것이다. 예를 들어 [12, 123]이 주어진다면 12 + 123으로도 붙여보고 123 + 12로도 붙여본다. 이후 결과값들을 비교한다면 위의 사항들을 신경 쓰지 않고도 
간단하게 이를 비교할 수 있다.

## 기타
비교를 위한 compare 함수를 다음과 같이 한 줄로 간략화할 수 있다.
```python
def compare(n1, n2):
    return (n1 + n2 < n2 + n1) - (n1 + n2 > n2 + n1)
```
이는 True를 1, False를 0의 값을 갖기 때문이다. 따라서 결과에 따라 자동적으로 -1, 0, 1을 나타내, if 문을 쓰지 않고도 비교를 할 수 있다.  
하지만 실제로 실행해보면 if문을 사용한 것보다 확실하게 더 느린 것을 볼 수 있었다.
|if 문을 통한 비교|뺄셈을 통한 비교|
|:---|:---|
|테스트 1 〉	통과 (303.84ms, 20.9MB)|테스트 1 〉	통과 (338.96ms, 20.9MB)|
|테스트 2 〉	통과 (154.98ms, 15.9MB)|테스트 2 〉	통과 (176.96ms, 16MB)|
|테스트 3 〉	통과 (397.88ms, 24.3MB)|테스트 3 〉	통과 (455.38ms, 24.2MB)|
|테스트 4 〉	통과 (6.67ms, 10.3MB)|테스트 4 〉	통과 (10.32ms, 10.4MB)|
|테스트 5 〉	통과 (267.21ms, 19.8MB)|테스트 5 〉	통과 (295.14ms, 19.7MB)|
|테스트 6 〉	통과 (232.09ms, 18.6MB)|테스트 6 〉	통과 (254.85ms, 18.6MB)|
|테스트 7 〉	통과 (0.04ms, 10.2MB)|테스트 7 〉	통과 (0.04ms, 10.1MB)|
|테스트 8 〉	통과 (0.03ms, 10.2MB)|테스트 8 〉	통과 (0.03ms, 10.1MB)|
|테스트 9 〉	통과 (0.02ms, 10.2MB)|테스트 9 〉	통과 (0.03ms, 10.2MB)|
|테스트 10 〉	통과 (0.02ms, 10.1MB)|테스트 10 〉	통과 (0.03ms, 10.2MB)|
|테스트 11 〉	통과 (0.00ms, 10.3MB)|테스트 11 〉	통과 (0.00ms, 10.2MB)|

</br></br>

이와는 별개로 프로그래머스에서 가장 추천을 많이 받은 풀이법을 보고, 이렇게도 풀 수 있구나 하는 생각이 들어 이를 남기고자 한다.
```python
def solution(numbers):
    numbers = list(map(str, numbers))
    numbers.sort(key=lambda x: x*3, reverse=True)
    return str(int(''.join(numbers)))
```

위의 풀이법은 각 문자를 3번 반복하여 비교하는 방법인데, 이를 이해하기 위해선 먼저 파이썬이 문자열을 비교할 때 실제 숫자로 변환된 값을 비교하는 것이 아니라 
인덱스 별로 아스키 코드를 비교하는 것을 알아야 한다. 따라서 '2'>'10'을 비교한다면 이는 True가 된다. 

여기서 3번 반복하여 주는 이유는 문자열 비교 시 두 문자열의 길이가 다르고 하나의 문자열이 끝날 때까지 숫자가 같다면 더 긴 문자열이 큰 값이 되기 때문이다. 
예를 들어 '2'>'21'은 False, 즉 '21'이 더 큰 값이 된다. 하지만 이 경우 212로 문자열을 붙이는 것보다 221로 문자열을 붙이는 것이 더 크다. 
따라서 3번 반복하여 준다면 이를 해결할 수 있다. 예를 들어 '2'와 '21'을 3번 반복하면 '222', '212121'이 된다. 이 경우 문자열 비교 연산을 수행하면 원래 의도했던 것처럼 2가 먼저 오게 할 수 있다. 

이때, 최소 3번 이상은 반복하여야 원하는 답을 얻을 수 있다. 예를 들어 2번만 반복한다면, ['2', '221']이 주어진다면 '22', '221221'이 되므로 의도와 다르게 2221이 아닌 2212의 결과를 초래할 수 
있다. 여기서 3번이라는 기준은 'numbers의 원소는 0 이상 1,000 이하입니다.'라는 제한이 존재하기 때문에 세울 수 있다. 만약 0 이상 10,000 이하라면 최소 4번은 반복하여야 한다.
