# [2019 KAKAO BLIND RECRUITMENT] 무지의 먹방 라이브
## 문제
### 문제 설명
([원본 문제](https://programmers.co.kr/learn/courses/30/lessons/42891)의 내용을 복사한 것입니다.)

### 무지의 먹방 라이브

평소 식욕이 왕성한 무지는 자신의 재능을 뽐내고 싶어 졌고 고민 끝에 카카오 TV 라이브로 방송을 하기로 마음먹었다.

![무지](https://user-images.githubusercontent.com/77680436/118359694-a49bff80-b5bf-11eb-87de-58f209b001f0.png)

그냥 먹방을 하면 다른 방송과 차별성이 없기 때문에 무지는 아래와 같이 독특한 방식을 생각해냈다.

회전판에 먹어야 할 N 개의 음식이 있다.  
각 음식에는 1부터 N 까지 번호가 붙어있으며, 각 음식을 섭취하는데 일정 시간이 소요된다.  
무지는 다음과 같은 방법으로 음식을 섭취한다.

* 무지는 1번 음식부터 먹기 시작하며, 회전판은 번호가 증가하는 순서대로 음식을 무지 앞으로 가져다 놓는다.
* 마지막 번호의 음식을 섭취한 후에는 회전판에 의해 다시 1번 음식이 무지 앞으로 온다.
* 무지는 음식 하나를 1초 동안 섭취한 후 남은 음식은 그대로 두고, 다음 음식을 섭취한다.
  * 다음 음식이란, 아직 남은 음식 중 다음으로 섭취해야 할 가장 가까운 번호의 음식을 말한다.
* 회전판이 다음 음식을 무지 앞으로 가져오는데 걸리는 시간은 없다고 가정한다.

무지가 먹방을 시작한 지 K 초 후에 네트워크 장애로 인해 방송이 잠시 중단되었다.  
무지는 네트워크 정상화 후 다시 방송을 이어갈 때, 몇 번 음식부터 섭취해야 하는지를 알고자 한다.  
각 음식을 모두 먹는데 필요한 시간이 담겨있는 배열 food_times, 네트워크 장애가 발생한 시간 K 초가 매개변수로 주어질 때 몇 번 음식부터 다시 섭취하면 되는지 return 하도록 solution 함수를 완성하라.

### 제한사항
* food_times 는 각 음식을 모두 먹는데 필요한 시간이 음식의 번호 순서대로 들어있는 배열이다.
* k 는 방송이 중단된 시간을 나타낸다.
* 만약 더 섭취해야 할 음식이 없다면 `-1`을 반환하면 된다.

### 정확성 테스트 제한 사항
* food_times 의 길이는 `1` 이상 `2,000` 이하이다.
* food_times 의 원소는 `1` 이상 `1,000` 이하의 자연수이다.
* k는 `1` 이상 `2,000,000` 이하의 자연수이다.

### 효율성 테스트 제한 사항
* food_times 의 길이는 `1` 이상 `200,000` 이하이다.
* food_times 의 원소는 `1` 이상 `100,000,000` 이하의 자연수이다.
* k는 `1` 이상 `2 x 10^13` 이하의 자연수이다.

### 입출력 예
|food_times|k|result|
|:---|:---|:---|
|[3, 1, 2]|5|1|

### 입출력 예 설명
입출력 예 #1

* 0~1초 동안에 1번 음식을 섭취한다. 남은 시간은 [2,1,2] 이다.
* 1~2초 동안 2번 음식을 섭취한다. 남은 시간은 [2,0,2] 이다.
* 2~3초 동안 3번 음식을 섭취한다. 남은 시간은 [2,0,1] 이다.
* 3~4초 동안 1번 음식을 섭취한다. 남은 시간은 [1,0,1] 이다.
* 4~5초 동안 (2번 음식은 다 먹었으므로) 3번 음식을 섭취한다. 남은 시간은 [1,0,0] 이다.
* 5초에서 네트워크 장애가 발생했다. 1번 음식을 섭취해야 할 때 중단되었으므로, 장애 복구 후에 1번 음식부터 다시 먹기 시작하면 된다.

## 제출답안
```python
def solution(food_times, k):
    food_times = list(enumerate(food_times)) # 음식의 번호, 남은 시간 쌍
    food_times.sort(key=lambda x: x[1], reverse=True) # 음식의 남은 시간을 기준으로 내림차순 정렬
    laps = 0 # 회전판이 회전한 횟수
    
    # 네트워크 장애까지 남은 시간 동안 현재 남은 음식들을 기준으로 돌 수 있는 회전수가
    # 남은 시간이 가장 적은 음식을 다 먹기 위한 횟수 이상인 동안 반복
    while food_times and k // len(food_times) >= food_times[-1][1]-laps:
        now = food_times[-1][1]-laps # 현재 남은 시간이 가장 적은 음식을 다 먹기 위한 횟수
        k -= now * len(food_times) # 위의 횟수만큼 먹기 위해 걸리는 시간 차감
        laps += now # 회전판이 회전한 횟수 추가
        while food_times and laps == food_times[-1][1]: # 남은 시간이 가장 적었던 음식을 회전판에서 제거
            food_times.pop()
    
    return sorted(food_times)[k%len(food_times)][0]+1 if food_times else -1 # 음식을 모두 다 먹었다면 -1 반환
```
### 설명
본 문제를 풀기 위해서 가장 간단하게 푼다면 큐와 같은 자료구조를 이용하여 1초마다 음식의 남은 시간을 차감하는 방식으로 시뮬레이션 할 수 있다.

하지만 이러한 방식으로는 `k`가 커지면 그만큼 반복을 수행해야 한다는 단점이 있어 효율적이지 못 하다.

따라서 초마다 음식을 먹는 것을 시뮬레이션하는 대신 더 효율적인 방안이 필요하다. 이를 위해서는 `k`, 즉 네트워크 장애까지 남은 시간을 빠르게 차감하도록 만들어야 한다.

본 답안에서는 이러한 방안으로 음식을 남은 시간을 기준을 정렬하여 `k`를 한 번에 차감하는 방법을 사용한다.

`food_times`의 각 음식마다 남은 시간은 다시 말해 해당 음식을 모두 섭취하기 위해서 필요한 횟수이다. 회전판이 정확히 한 번 회전하면 현재 남은 모든 음식의 횟수를 1회씩 차감할 수 있다. 
또한 회전판을 한 바퀴 회전한다는 것은 시간이 회전판에 남은 음식의 개수(초)만큼 진행됐다는 것이다.

이를 이용한다면 1초씩이 아니라 음식의 길이만큼 한 번에 계산할 수 있다는 장점이 생긴다. 이러한 아이디어를 이용하기 위해서 고려할 사항이 있다.  
`k`를 1초가 아니라 남은 음식의 길이만큼 정확하게 차감하기 위해서는 회전판에 남은 시간이 0이 된 음식은 제거해주어야 한다는 것이다.

회전판의 음식 현황을 갱신하기 위해서 food_times를 순회하면서 남은 시간이 0이 된 음식을 제외하고 새롭게 리스트를 만드는 방식은 입력 인자의 길이에 따라 시간이 여전히 오래 걸릴 수 있다.

food_times를 순회하지 않고 다 먹은 음식을 제거할 수 있는 방법으로는 회전판의 회전 횟수를 기록하고 food_times를 정렬하는 방법이 있다.

먼저 food_times를 가장 먼저 제거될 음식이 뭔지 알 수 있도록 내림차순 정렬한다. 이렇게 한다면 food_times를 순회하지 않고도 가장 끝 부분만 비교하여 pop 하는 방식으로 제거할 수 있다.

그렇다면 음식의 남은 횟수를 어떻게 확인할 수 있을까. 가장 맨 처음, 즉 한 바퀴를 돌기 전에는 음식의 남은 시간은 해당 의미 그대로 받아들이면 된다. 
하지만 food_times를 순회하면서 남은 시간을 차감시키지 않기 때문에 한 바퀴를 돌고난 이후부터는 음식의 남은 시간은 실제 해당 음식의 남은 시간이 아니게 된다.

따라서 이를 알기 위해서 회전판의 회전 횟수를 기록하는 것이다. 회전판의 회전 횟수를 기록한다면 `food_times에 기록된 음식의 남은 시간-회전 횟수`를 계산하여 실제 남은 시간을 계산할 수 있다.

이제 이 둘을 이용하여 효율적으로 알고리즘을 작성해보자.

1. food_times를 정렬하기 이전에 각 음식의 번호를 정렬 후에도 알 수 있게 음식의 번호와 음식의 남은 시간 쌍으로 저장한다.
2. food_times를 내림차순 정렬한다. (파이썬에서는 리스트의 뒤를 pop 하는 것이 빠르기 때문)
3. 네트워크 장애까지 남은 시간 동안 현재 남은 음식들을 기준으로 돌 수 있는 회전수(`k // len(food_times)`)가 남은 시간이 가장 적은 음식을 다 먹기 위한 횟수(`food_times[-1][1]-laps`)
 이상인지 확인한다.
4. 만약 3번을 만족한다면 네트워크 장애까지 적어도 남은 시간이 가장 적은 음식은 다 먹을 수 있다는 소리이므로 남은 시간이 가장 적은 음식(들)을 회전판에서 제거한다.
5. 이에 맞게 회전수를 음식이 남아있던 횟수만큼 증가시키고 진행된 시간을 `남은 시간이 가장 적은 음식을 다 먹기 위한 횟수(회전수) * 음식의 개수`만큼 계산한다.
6. 4번 ~ 5번을 3번이 만족하는 동안 반복한다.
7. 반복이 끝난 후 회전판에 음식이 남아있지 않다면 `-1`을 반환한다.
8. 음식이 남아있다면 남은 음식을 원래 번호에 맞게 정렬하고 장애까지 남은 시간을 이용하여 몇 번 음식을 먹을 순서인지 계산해 반환한다.(`sorted(food_times)[k%len(food_times)][0]+1`)

이러한 과정으로 코딩한 것이 제출 답안이 된다.
