# [프로그래머스] 소수 찾기
## 문제
### 문제 설명
([원본 문제](https://programmers.co.kr/learn/courses/30/lessons/42839)의 내용을 복사한 것입니다.)

한자리 숫자가 적힌 종이 조각이 흩어져있습니다. 흩어진 종이 조각을 붙여 소수를 몇 개 만들 수 있는지 알아내려 합니다.

각 종이 조각에 적힌 숫자가 적힌 문자열 numbers가 주어졌을 때, 종이 조각으로 만들 수 있는 소수가 몇 개인지 return 하도록 solution 함수를 완성해주세요.

### 제한사항
* numbers는 길이 1 이상 7 이하인 문자열입니다.
* numbers는 0~9까지 숫자만으로 이루어져 있습니다.
* "013"은 0, 1, 3 숫자가 적힌 종이 조각이 흩어져있다는 의미입니다.

### 입출력 예
|numbers|return|
|:---|:---|
|"17"|3|
|"011"|2|

### 입출력 예 설명
예제 #1  
[1, 7]으로는 소수 [7, 17, 71]를 만들 수 있습니다.

예제 #2  
[0, 1, 1]으로는 소수 [11, 101]를 만들 수 있습니다.  
* 11과 011은 같은 숫자로 취급합니다.

## 제출답안
```python
from math import sqrt # 소수 판별을 효율적으로 하기 위함

primeNum = set() # 주어진 종이 조각을 조합하여 만들 수 있는 소수들
def isPrime(num): # 소수인지 판별
    if num < 2: return False
    for i in range(2, int(sqrt(num))+1):
        if not num % i: return False
    return True

def dfs(idx, numbers, visited, num): # 만들 수 있는 모든 경우의 수를 탐색
    visited[idx] = True
    if isPrime(int(num)): primeNum.add(num) # primeNum이 집합 자료형이므로 중복된 값 체크 불필요
        
    for i in range(len(visited)):
        if not visited[i]:
            dfs(i, numbers, visited, num+numbers[i])
            
    visited[idx] = False
    # 숫자의 순서가 다른 경우를 위함
    # 예를 들어 주어진 숫자가 "123"인 경우 "123"를 탐색하고 "132"도 탐색하기 위함

def solution(numbers):
    visited = [False for _ in range(len(numbers))]
    
    for i in range(len(numbers)):
        if int(numbers[i]): # 0으로 시작하는 경우는 어차피 다른 경우와 같은 숫자로 취급하므로 불필요
            dfs(i, numbers, visited, numbers[i])
    
    return len(primeNum)
```
### 설명
문제를 이해하기 위해 먼저 예를 들어 numbers가 "123"으로 주어졌을 때, 가능한 경우의 수는 다음과 같다.

|No|숫자|
|:-|:-|
|1|1|
|2|12|
|3|123|
|4|13|
|5|132|
|6|2|
|7|21|
|8|213|
|9|23|
|10|231|
|11|3|
|12|31|
|13|312|
|14|32|
|15|321|

총 경우의 수는 3개 중에 1개를 순서를 고려하여 나열하는 경우의 수 + 3개 중에 2개를 순서를 고려하여 나열하는 경우의 수 + 3개 중에 3개를 순서를 고려하여 나열하는 경우의 수와 같으므로, 
다음과 같이 나타낼 수 있다.

> 총 경우의 수 = <sub>3</sub>P<sub>1</sub> + <sub>3</sub>P<sub>2</sub> + <sub>3</sub>P<sub>3</sub> = 3 + 6 + 6 = 15

본 문제를 풀기 위해선 위와 같이 총 15개의 경우의 수를 모두 탐색하여 소수인 것을 판별하면 된다. 위의 표와 같이 모든 경우의 수를 탐색하기 위해서 DFS를 사용할 수 있다. 
여기서 구현한 DFS는 해당 숫자로 시작하여 만들 수 있는 모든 숫자를 탐색한다. 예를 들어 DFS의 시작 노드가 1이라고 한다면 1, 12, 13, 123, 132 의 경우를 탐색한다. 
이 경우를 트리 형태로 이미지화 하여보면 다음과 같다.
<img width="720" alt="예시1" src="https://user-images.githubusercontent.com/77680436/109030781-749f3780-7707-11eb-98b2-04a110095fa2.png">  
위의 트리에서 1로 시작하여 DFS를 수행한다면 1, 12, 123, 13, 132의 순으로 탐색한다.

따라서 시작 노드가 1일때, 2일 때, 3일 때의 DFS를 모두 수행한다면, 이는 전체 경우의 수 15개를 모두 탐색하는 것이다. 
이때, 시작 노드의 숫자가 0인 경우는 어차피 다른 다른 노드에서의 시작한 경우에서 모두 탐색하기 때문에 수행하지 않는다.  
(본 문제에서 ```11과 011은 같은 숫자로 취급합니다.```와 같이 설명하고 있기 때문)

보통의 DFS의 경우 정확히 모든 노드를 한 번씩만 방문한다. 따라서 이를 고려하지 않고 구현할 시, 위의 1에서 시작하는 DFS의 경우 1, 12, 123을 탐색하고 멈추어버린다. 
이를 해결하기 위해서 직접 위의 그림과 같은 트리를 만들어 수행할 수도 있지만, 굳이 트리를 만들지 않고 주어진 numbers 만으로 DFS를 수행하기 위해선 제출답안과 같이 DFS 함수의 
마지막에 자신의 방문 여부를 다시 False로 바꾸어 주기만 하면 된다. 즉, stack으로 생각한다면 pop을 할 때 방문 여부를 False로 변경하여 주면 된다,

이를 트리 구조로 이미지화하여 예시로 살펴보면 다음과 같은 과정을 거쳐 DFS가 진행된다.
<img width="720" alt="예시2" src="https://user-images.githubusercontent.com/77680436/109035423-fabd7d00-770b-11eb-960f-543e4c198999.gif">  

이렇게 한다면 자동으로 DFS가 끝날을 때 모든 방문 여부가 초기화 되므로, 굳이 매 DFS마다 초기화할 필요도 없다.

최종적으로 위와 같은 과정을 모든 숫자에 대해 시작하여 DFS를 수행하고, 그렇게 모든 경우의 수를 방문하면서 소수를 판별하여 primeNum 집합에 넣어주어 답을 구할 수 있다.
이때 집합 자료형이므로 자동적으로 중복은 존재하지 않는다.
