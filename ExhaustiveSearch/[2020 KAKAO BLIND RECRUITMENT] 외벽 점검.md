# [2020 KAKAO BLIND RECRUITMENT] 외벽 점검
## 문제
### 문제 설명
([원본 문제](https://programmers.co.kr/learn/courses/30/lessons/60062)의 내용을 복사한 것입니다.)

레스토랑을 운영하고 있는 <b>"스카피"</b>는 레스토랑 내부가 너무 낡아 친구들과 함께 직접 리모델링 하기로 했습니다. 레스토랑이 있는 곳은 스노우타운으로 매우 추운 지역이어서 내부 공사를 하는 도중에 주기적으로 외벽의 상태를 점검해야 할 필요가 있습니다.

레스토랑의 구조는 <b>완전히 동그란 모양</b>이고 <b>외벽의 총 둘레는 n미터</b>이며, 외벽의 몇몇 지점은 추위가 심할 경우 손상될 수도 있는 <b>취약한 지점들</b>이 있습니다. 따라서 내부 공사 도중에도 외벽의 취약 지점들이 손상되지 않았는 지, 주기적으로 친구들을 보내서 점검을 하기로 했습니다. 다만, 빠른 공사 진행을 위해 점검 시간을 1시간으로 제한했습니다. 친구들이 1시간 동안 이동할 수 있는 거리는 제각각이기 때문에, 최소한의 친구들을 투입해 취약 지점을 점검하고 나머지 친구들은 내부 공사를 돕도록 하려고 합니다. 편의 상 레스토랑의 정북 방향 지점을 0으로 나타내며, 취약 지점의 위치는 정북 방향 지점으로부터 시계 방향으로 떨어진 거리로 나타냅니다. 또, 친구들은 출발 지점부터 시계, 혹은 반시계 방향으로 외벽을 따라서만 이동합니다.

외벽의 길이 n, 취약 지점의 위치가 담긴 배열 weak, 각 친구가 1시간 동안 이동할 수 있는 거리가 담긴 배열 dist가 매개변수로 주어질 때, 취약 지점을 점검하기 위해 보내야 하는 친구 수의 최소값을 return 하도록 solution 함수를 완성해주세요.

### 제한사항
* n은 1 이상 200 이하인 자연수입니다.
* weak의 길이는 1 이상 15 이하입니다.
  * 서로 다른 두 취약점의 위치가 같은 경우는 주어지지 않습니다.
  * 취약 지점의 위치는 오름차순으로 정렬되어 주어집니다.
  * weak의 원소는 0 이상 n - 1 이하인 정수입니다.
* dist의 길이는 1 이상 8 이하입니다.
  * dist의 원소는 1 이상 100 이하인 자연수입니다.
* 친구들을 모두 투입해도 취약 지점을 전부 점검할 수 없는 경우에는 -1을 return 해주세요.

___

### 입출력 예
|n|weak|dist|result|
|:---|:---|:---|:---|
|12|[1, 5, 6, 10]|[1, 2, 3, 4]|2|
|12|[1, 3, 4, 9, 10]|[3, 5, 7]|1|

### 입출력 예에 대한 설명
**입출력 예 #1**

원형 레스토랑에서 외벽의 취약 지점의 위치는 다음과 같습니다.

<img width="420" alt="예시1" src="https://user-images.githubusercontent.com/77680436/118493821-7b64a600-b75c-11eb-90e5-0c6ec15fc9e2.png">

친구들을 투입하는 예시 중 하나는 다음과 같습니다.

* 4m를 이동할 수 있는 친구는 10m 지점에서 출발해 시계방향으로 돌아 1m 위치에 있는 취약 지점에서 외벽 점검을 마칩니다.
* 2m를 이동할 수 있는 친구는 4.5m 지점에서 출발해 6.5m 지점에서 외벽 점검을 마칩니다.

그 외에 여러 방법들이 있지만, 두 명보다 적은 친구를 투입하는 방법은 없습니다. 따라서 친구를 최소 두 명 투입해야 합니다.

**입출력 예 #2**

원형 레스토랑에서 외벽의 취약 지점의 위치는 다음과 같습니다.

<img width="420" alt="예시2" src="https://user-images.githubusercontent.com/77680436/118493993-a5b66380-b75c-11eb-8b2d-2fb1f44d92c5.png">

7m를 이동할 수 있는 친구가 4m 지점에서 출발해 반시계 방향으로 점검을 돌면 모든 취약 지점을 점검할 수 있습니다. 따라서 친구를 최소 한 명 투입하면 됩니다.

## 제출답안
```python
from itertools import combinations
def solution(n, weak, dist):
    answer = 0
    edge = set()
    dist.sort(reverse=True)

    for i in range(len(weak)): # (거리, 지점1, 지점2) 형태로 모든 간선 저장
        d = weak[(i+1)%len(weak)] - weak[i]
        d = n + d if d < 0 else d
        edge.add((d, weak[i], weak[(i+1)%len(weak)]))

    temp = max(edge)
    edge.remove(temp) # 간선에서 거리가 가장 큰 간선 제거
    if dist[0] >= n - temp[0]: return 1
    # 가장 많이 이동할 수 있는 친구의 거리가 취약 지점을 한 번에 잇는 가장 짧은 거리 이상일 경우(1명으로 가능)

    for i in range(1, len(dist)): # 간선을 추가로 제거하면서(친구 수를 늘려 가면서) 가능한지 검증
        for comb in combinations(edge, i): # 어떤 간선을 제거할지는 모든 경우의 수 고려
            connection = {w:[False, False] for w in weak} # {취약 지점: [누군가 나를 연결했는지, 내가 연결하고 있는 지점과 비용]} (시계방향)
            dis = [] # 지점들을 검사하기 위해 필요한 친구들의 최소 이동 거리

            for d, w1, w2 in edge - set(comb): # 간선을 제거한 후 연결 정보 생성
                connection[w1][1] = [w2, d]
                connection[w2][0] = True
            
            for isConnected, nextPoint in connection.values():
                if not isConnected: # 아무에게도 연결되어 있지 않은 경우
                    if not nextPoint: dis.append(1) # 동시에 아무에게도 연결하지 않는 경우(경로가 없이 단일 지점)
                    else: # 누군가 나를 연결하지 않았지만 내가 연결하고 있는 경우 = 이동 경로의 시작
                        d = nextPoint[1]
                        while connection[nextPoint[0]][1]: # 지점을 연결하며 경로의 거리 측정
                            nextPoint = connection[nextPoint[0]][1]
                            d += nextPoint[1]
                        dis.append(d) # 하나의 연결된 경로 길이 추가
            dis.sort(reverse=True)

            if all(dis[idx] <= dist[idx] for idx in range(len(dis))): # 현재 경우의 수가 가능한 경우
                return i+1

    return -1 # 친구들을 모두 투입해도 취약 지점을 전부 점검할 수 없는 경우
```
### 설명
제한사항을 봤을 때 인자의 길이가 크지 않은 것을 보아 완전 탐색 문제임을 예측할 수 있다.

본 답안에서 사용한 문제 해결 아이디어를 이해하기 위해서 먼저 가장 간단한 경우인 한 명이 점검 가능하는 경우를 생각해보자.

한 명이 점검하는 경우 가장 최소의 이동 거리는 무엇일까. 그것은 전체 길이에서 가장 긴 간선을 제거했을 때의 길이이다.

앞으로 초록색의 선은 친구 한 명이 이동해야하는 경로라고 생각해보자. 처음에는 모든 지점간의 간선을 전부 이은 상태에서 시작한다.

<img width="420" alt="설명1" src="https://user-images.githubusercontent.com/77680436/118583799-9a9d1b00-b7d0-11eb-8a78-9e2660c7b0c3.png">

이 상태에서 간선의 길이가 가장 긴 `4 ~ 9` 선을 제거 해보자.

<img width="420" alt="설명2" src="https://user-images.githubusercontent.com/77680436/118586528-e605f800-b7d5-11eb-9629-20dbf6839bc1.png">

그렇다면 이것이 한 명이 점검할 때 최소의 이동 거리가 될 것이다.

이제 여기서 하나의 간선을 더 지워보자. 이번에는 `10 ~ 1` 간선을 지울 것이다.

<img width="420" alt="설명3" src="https://user-images.githubusercontent.com/77680436/118586915-907e1b00-b7d6-11eb-85dd-9a3b5504e1a0.png">

그림을 보면 이제 이동 경로가 두 개가 되었다. 즉 친구 두 명의 경로가 되었다는 것이다.

최초의 상태에서 1개의 간선을 제거했을 때 친구 한 명의 이동 경로가 나왔다. 그리고 최초의 상태에서 2개의 간선을 제거했을 때는 친구 두 명의 이동 경로가 나왔다. 
그렇다면 `x`개의 간선을 제거하면 친구 `x`명의 이동 경로가 나온다는 것을 생각해볼 수 있다.

1개의 간선을 제거하는 것까지는 최소 경로를 유추할 수 있으므로 길이가 가장 큰 간선을 제거하는 것으로 고정한다. 2개부터는 모든 경우의 수를 고려해주어야 한다.  
즉,

1. 1명의 친구: 최초의 상태에서 길이가 가장 큰 간선을 제거한 경우로 고정
2. 2명의 친구: 1번의 상태에서 추가로 간선을 하나 더 제거하는 모든 경우 검사
3. `x`명의 친구: 1번의 상태에서 추가로 간선을 `x-1`개 더 제거하는 모든 경우 검사

이러한 식으로 완전 탐색을 수행할 수 있다.

이때, 주의해야 할 점이 있다. 간선의 길이가 가장 긴 `4 ~ 9` 선만을 제거한 상태로 되돌아가보자.

<img width="420" alt="설명2" src="https://user-images.githubusercontent.com/77680436/118586528-e605f800-b7d5-11eb-9629-20dbf6839bc1.png">

이번에는 `10 ~ 1`이 아닌 `3 ~ 4` 간선을 제거해볼 것이다.

<img width="420" alt="설명4" src="https://user-images.githubusercontent.com/77680436/118588310-169b6100-b7d9-11eb-903d-82d4f80349a8.png">

`3 ~ 4` 간선을 추가로 제거했더니 이동 경로가 하나밖에 없다. 즉 4번 지점을 검사하지 못 한다는 것이다.  
이를 해결하기 위해서 이럴 때는 동떨어진 지점에 임의로 길이가 1인 이동 경로를 만들어주는 방법을 사용하였다.

<img width="420" alt="설명5" src="https://user-images.githubusercontent.com/77680436/118588902-4bf47e80-b7da-11eb-828c-6b0a8f14f94c.png">

이제 어떠한 아이디어로 완전 탐색을 수행하는지, 그리고 주의할 점이 무엇인지도 고려해보았다. 이번에는 이것을 어떻게 구현할지 생각해보자.

구현할 때 고려할 점은 무엇이 있을까. 우리는 두 가지를 판단해야 한다.

1. 동떨어진 지점
2. 이어진 간선의 길이

동떨어진 지점의 경우 무슨 의미인지 쉽게 알 수 있으리라 생각한다. 그렇다면 이어진 간선의 길이는 무엇을 의미하는 것일까.

다시 한 번 간선의 길이가 가장 긴 `4 ~ 9` 선만을 제거한 상태로 되돌아가보자.

<img width="420" alt="설명2" src="https://user-images.githubusercontent.com/77680436/118586528-e605f800-b7d5-11eb-9629-20dbf6839bc1.png">

여기서 우리는 `9 ~ 10`, `10 ~ 1`, `1 ~ 3`, `3 ~ 4` 4개의 간선을 하나의 이동 경로로 판단할 수 있어야 한다. 즉, 간선이 이어져있을 때 이어진 간선들은 합쳐서 하나의 경로로 생각하도록 구현해야 한다는 것이다.

본 답안에서는 1번과 2번을 모두 고려하면서 구현하기 위해 다음과 같은 방법을 사용하였다.

먼저 각 취약 지점마다의 연결 정보를 저장할 해시 테이블을 생성한다. 해시 테이블의 값으로는 `[누군가 나를 연결했는지, 내가 연결하고 있는 지점과 비용]`이 들어간다. 이게 무슨 소리인지 살펴보자.

위의 사진을 시계 방향으로 생각해보자.

* 9번 지점은 10번 지점을 연결하고 있다.
* 10번 지점은 9번 지점에게 연결되어 있으며 1번 지점을 연결하고 있다.
* 1번 지점은 10번 지점에게 연결되어 있으며 3번 지점을 연결하고 있다. 
* 3번 지점은 1번 지점에게 연결되어 있으며 4번 지점을 연결하고 있다.
* 4번 지점은 3번 지점에게 연결되어 있다.

쉽게 생각하면 9번 지점부터 4번 지점까지를 직선으로 생각해보자. 어떤 지점을 기준으로 왼쪽 지점에서 오는 간선은 누군가 나를 연결한 간선, 오른쪽 지점으로의 간선은 내가 연결하고 있는 지점으로의 간선이 되는 것이다.

이런 식으로 연결 정보를 생성해보면, 이제 1번과 2번을 판단할 수 있다.

먼저 누군가 나를 연결하지도 않았으며(왼쪽에서 오는 간선이 없음) 동시에 내가 연결하고 있는 지점도 없다면(오른쪽으로 간선이 없음) 해당 취약 지점은 동떨어진 지점이라는 의미이다.  
따라서 이런 경우에는 임의로 해당 지점을 위한 길이가 1인 경로를 추가해주면 된다.

다음으로 누군가 나를 연결하지는 않았지만, 내가 누군가를 연결하고 있다면 해당 취약 지점은 경로의 시작 지점으로 볼 수 있다. 즉 해당 지점부터 아무 곳에도 연결하고 있지 않은 지점(경로의 끝)을 
만날 때까지 간선을 따라서 연결하면 하나의 이어진 간선의 경로 길이를 얻을 수 있다.

이렇게 친구가 `x`명일 때의 경로 길이들을 구했다면, 이를 내림차순 정렬한다. 또한 마찬가지로 각 친구가 1시간 동안 이동할 수 있는 거리가 담긴 배열 `dist` 역시 내림차순 정렬한다.

내림차순 정렬된 두 개의 리스트를 같은 인덱스끼리 비교한다면 최대 길이 경로는 최대로 이동할 수 있는 친구가, 그 다음으로 긴 경로는 그 다음으로 많이 이동할 수 있는 친구가 담당하게 될 것이다.  
따라서 같은 인덱스에 있는 친구의 거리와 경로의 거리를 비교하여 모든 경로의 거리보다 대응되는 친구의 거리가 전부 크거나 같으면 해당 경우의 수는 점검 가능한 경우로 볼 수 있다.

이를 친구가 1명일 때, 2명일 때, 이런 식으로 1명씩 늘려가면서 판단하면 가장 먼저 가능한 경우가 최소 인원이 된다.
