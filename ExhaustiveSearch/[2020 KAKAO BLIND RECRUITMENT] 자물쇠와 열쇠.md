# [2020 KAKAO BLIND RECRUITMENT] 자물쇠와 열쇠
## 문제
### 문제 설명
([원본 문제](https://programmers.co.kr/learn/courses/30/lessons/60059)의 내용을 복사한 것입니다.)

고고학자인 `"튜브"`는 고대 유적지에서 보물과 유적이 가득할 것으로 추정되는 비밀의 문을 발견하였습니다. 그런데 문을 열려고 살펴보니 특이한 형태의 `자물쇠`로 잠겨 있었고 문 앞에는 특이한 형태의 `열쇠`와 함께 자물쇠를 푸는 방법에 대해 다음과 같이 설명해 주는 종이가 발견되었습니다.

잠겨있는 자물쇠는 격자 한 칸의 크기가 `1 x 1`인 `N x N` 크기의 정사각 격자 형태이고 특이한 모양의 열쇠는 `M x M` 크기인 정사각 격자 형태로 되어 있습니다.

자물쇠에는 홈이 파여 있고 열쇠 또한 홈과 돌기 부분이 있습니다. 열쇠는 회전과 이동이 가능하며 열쇠의 돌기 부분을 자물쇠의 홈 부분에 딱 맞게 채우면 자물쇠가 열리게 되는 구조입니다. 자물쇠 영역을 벗어난 부분에 있는 열쇠의 홈과 돌기는 자물쇠를 여는 데 영향을 주지 않지만, 자물쇠 영역 내에서는 열쇠의 돌기 부분과 자물쇠의 홈 부분이 정확히 일치해야 하며 열쇠의 돌기와 자물쇠의 돌기가 만나서는 안됩니다. 또한 자물쇠의 모든 홈을 채워 비어있는 곳이 없어야 자물쇠를 열 수 있습니다.

열쇠를 나타내는 2차원 배열 key와 자물쇠를 나타내는 2차원 배열 lock이 매개변수로 주어질 때, 열쇠로 자물쇠를 열수 있으면 true를, 열 수 없으면 false를 return 하도록 solution 함수를 완성해주세요.

### 제한사항
* key는 M x M(3 ≤ M ≤ 20, M은 자연수)크기 2차원 배열입니다.
* lock은 N x N(3 ≤ N ≤ 20, N은 자연수)크기 2차원 배열입니다.
* M은 항상 N 이하입니다.
* key와 lock의 원소는 0 또는 1로 이루어져 있습니다.
  * 0은 홈 부분, 1은 돌기 부분을 나타냅니다.

___

### 입출력 예
|key|lock|result|
|:---|:---|:---|
|[[0, 0, 0], [1, 0, 0], [0, 1, 1]]|[[1, 1, 1], [1, 1, 0], [1, 0, 1]]|true|

### 입출력 예에 대한 설명
<img width="512" alt="예시" src="https://user-images.githubusercontent.com/77680436/113864386-cdbdb900-97e5-11eb-9af6-bfa0ac30201b.png">

key를 시계 방향으로 90도 회전하고, 오른쪽으로 한 칸, 아래로 한 칸 이동하면 lock의 홈 부분을 정확히 모두 채울 수 있습니다.

## 제출답안
```python
def rotate(key, length): # 열쇠의 좌표들을 90도 회전하여 반환
    return {(j, length-i) for i, j in key}

def move(key, diff): # 열쇠의 위치를 행과 열의 차이만큼 이동하여 반환
    return {(i+diff[0], j+diff[1]) for i, j in key}

def solution(key, lock):
    answer = True
    _key, _lock, __lock = set(), set(), set()
    # 열쇠의 돌기, 자물쇠의 홈, 자물쇠의 돌기의 좌표(행, 열)

    for i in range(len(key)): # 열쇠의 돌기 위치 저장
        for j in range(len(key)):
            if key[i][j]: _key.add((i, j))

    for i in range(len(lock)): # 자물쇠의 홈과 돌기 위치 저장
        for j in range(len(lock)):
            if lock[i][j]: __lock.add((i, j))
            else: _lock.add((i, j))

    if not len(_lock):return True # 자물쇠에 홈이 없는 경우는 항상 참
    if len(_lock) > len(_key): return False # 자물쇠의 홈보다 열쇠의 돌기 수가 적은 경우 항상 거짓

    temp = next(iter(_lock)) # 자물쇠의 홈 중 하나의 위치를 고름
    for _ in range(4): # 열쇠를 회전시켜가며 자물쇠를 열 수 있는지 확인, 4번 회전시키면 결국 제자리이므로 범위는 4
        diff = []

        for i, j in _key: # 열쇠의 각 돌기 위에서 고른 위치의 행, 열 차이 값을 모두 저장
            diff.append((temp[0]-i,temp[1]-j))

        for d in diff:
            _temp = move(_key, d) # 열쇠의 위치를 차이 값만큼 이동 시켜봄
            if not len(_lock-_temp) and not len(__lock&_temp): # 이동 결과 열쇠의 돌기가 홈을 모두 채우면서 자물쇠 돌기와 맞물리지 않으면 True
                return True

        _key = rotate(_key, len(key)-1) # 이동을 모두 시켜보아도 자물쇠를 열 수 없다면 열쇠를 회전

    return False
```
### 설명
본 문제의 경우 카카오 공식 블로그에 따르면 원래의 의도는 `'2차원 배열을 다룰 수 있는지 파악'`하기 위함으로, 배열을 통해 완전탐색을 하는 문제였다.

카카오에서는 열쇠가 자물쇠 범위를 벗어날 수 있음을 고려해서 자물쇠의 가로, 세로 3배에 달하는 판을 만들었다.(`M은 항상 N 이하입니다.`라는 제한 조건에 의해 가능)  
이후 자물쇠를 중앙으로 배치한 후, 열쇠를 좌상단부터 우하단까지 순서대로 이동시키며 확인한다. 이러한 과정을 열쇠가 회전을 4번할 동안(4번 회전 시 제자리이므로) 수행하며 확인하는 과정으로 문제를 해결하였다.

하지만 본 풀이법에서는 약간은 다른 방법을 사용하였다. 배열 전체를 직접 이동시키기 보다는 배열의 (행, 열) 좌표 값을 통하여 계산하는 방법을 사용하였다.

먼저 열쇠의 돌기와 자물쇠의 홈, 돌기 좌표 값을 저장한다.
이후 열쇠가 회전하는 것을 구현하기 위하여 직접 행과 열이 어떻게 변화하는지 살펴본 결과 `(행, 열) → (열, 행(또는 열)의 최대 값-행)`의 형태로 변하는 것을 확인하였다.

예를 들어서 `3 x 3`인 열쇠가 있다고 할 때, 첫 번째 행만 고려해보자.

![회전 예시](https://user-images.githubusercontent.com/77680436/113868779-0318d580-97eb-11eb-9461-ffb9351169a4.png)

그림과 같이 (행, 열)이 `(행, 열) → (열, 행(또는 열)의 최대 값-행)`의 형태로 변하는 것을 확인할 수 있다.
따라서 회전 함수의 경우 이러한 방식으로 구현하였다.

이제 열쇠의 이동을 구현하여야 한다. 열쇠의 이동을 구현하기 위해 좌상단부터 우상단으로 하나씩 이동하는 것처럼 모든 경우를 완전 탐색할 수도 있지만, 좌표 값을 이용하는 만큼 
죄표를 직접 더하거나 뺴는 방법이 더 효율적일 것이다. 그렇다면 좌표가 이동할 수 있는 모든 경우를 어떻게 구할 수 있을까.

이는 자물쇠의 홈 중 하나와 열쇠의 모든 좌표간의 차이들로 구할 수 있다. 이는 아래의 그림을 보자.

![이동 예시1](https://user-images.githubusercontent.com/77680436/113871325-bda9d780-97ed-11eb-97f1-b771c6e48b31.png)

자물쇠의 홈 중 `[1]`번 홈을 정했다고 해보자. 그렇다면 열쇠는 `[1]`번 홈을 메우기 위해서 `(1), (2), (3)` 세 개의 홈 중에서 하나가 와야할 것이다.

따라서 `[1]과 (1), [1]과 (2), [1]과 (3)`의 차이를 모두 구해 열쇠를 해당 차이만큼 모두 이동시켜보는 것이다. 즉, `[1]`번 홈에 `(1)` 돌기가 오도록 이동시켜보거나, 
`(2)` 돌기가 오도록 이동시켜보거나, 혹은 `(3)` 돌기가 오도록 이동시켜보는 것이다. 만약 현재 각도에서 자물쇠를 열 수 있는 답이 있다면 3가지 경우의 수 중에서 답이 나올 것이다.

이를 그림으로 나타내보면 다음과 같이 열쇠가 이동할 수 있다.
![이동 예시2](https://user-images.githubusercontent.com/77680436/113872154-97d10280-97ee-11eb-8ac7-eae0165f0f93.png)

여기서 `[1]`번 홈에 `(1)`번 돌기가 오도록 이동시켰을 경우에 자물쇠를 열 수 있다.  
이처럼 열쇠가 이동할 수 있는 최소한의 경우는 위와 같이 구할 수 있으며, 이를 이용하여 열쇠의 이동을 구현할 수 있다.

마지막으로 현재 열쇠의 위치가 자물쇠와 맞는지 어떻게 확인할 수 있을까. 열쇠의 돌기가 자물쇠의 범위를 벗어날 수도 있기 때문에 열쇠의 돌기를 모두 사용하지 않고도 자물쇠의 홈을 메울 수도 있다. 
즉, 열쇠의 돌기 위치와 자물쇠의 홈 위치가 모두 동일한 경우가 아닐 수 있다는 것이다. 따라서 본 답안에서는 집합 연산을 이용하여 이를 구현하였다.

먼저 열쇠의 돌기가 자물쇠의 홈을 모두 메울 수 있는지는 차집합을 이용할 수 있다. `자물쇠의 홈 위치 집합 - 열쇠의 돌기 위치 집합`을 했을 때 자물쇠의 홈을 모두 메운다면 결과는 공집합이 될 것이다.

자물쇠의 돌기와 열쇠의 돌기가 만나는지는 교집합을 이용할 수 있다. `자물쇠의 돌기 위치 집합 & 열쇠의 돌기 위치 집합`을 했을 때, 자물쇠와 열쇠의 돌기가 서로 만나지 않는다면 결과는 역시 공집합이 될 것이다.

따라서 두 결과가 모두 공집합이 되는 경우가 있다면 자물쇠를 해당 열쇠를 이용하여 열 수 있다는 말이 된다.

이처럼 본 답안에서는 배열의 이동을 통한 완전탐색보다는 (행, 열) 좌표를 통한 계산으로 조금 더 빠르게 결과를 얻어낼 수 있다.
