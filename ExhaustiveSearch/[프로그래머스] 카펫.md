# [프로그래머스] 카펫
## 문제
### 문제 설명
([원본 문제](https://programmers.co.kr/learn/courses/30/lessons/42842)의 내용을 복사한 것입니다.)

Leo는 카펫을 사러 갔다가 아래 그림과 같이 중앙에는 노란색으로 칠해져 있고 테두리 1줄은 갈색으로 칠해져 있는 격자 모양 카펫을 봤습니다.

<img width="400" alt="예시" src="https://user-images.githubusercontent.com/77680436/108177752-f4953280-7146-11eb-8536-38c76e755ffc.png">

Leo는 집으로 돌아와서 아까 본 카펫의 노란색과 갈색으로 색칠된 격자의 개수는 기억했지만, 전체 카펫의 크기는 기억하지 못했습니다.

Leo가 본 카펫에서 갈색 격자의 수 brown, 노란색 격자의 수 yellow가 매개변수로 주어질 때 카펫의 가로, 세로 크기를 순서대로 배열에 담아 return 하도록 solution 함수를 작성해주세요.

### 제한사항
* 갈색 격자의 수 brown은 8 이상 5,000 이하인 자연수입니다.
* 노란색 격자의 수 yellow는 1 이상 2,000,000 이하인 자연수입니다.
* 카펫의 가로 길이는 세로 길이와 같거나, 세로 길이보다 깁니다.

### 입출력 예
|brown|yellow|return|
|:---|:---|:---|
|10|2|[4, 3]|
|8|1|[3, 3]|
|24|24|[8, 6]|

## 제출답안
```python
def solution(brown, yellow):
    for w in range(3, brown//2): # 가로 길이는 최소 3, 최대 (brown/2) - 1
        for h in range(3, w+1): # 세로 길이는 최소 3이며, 가로보다 작거나 같음
            if w*h == brown+yellow and (w-2)*(h-2) == yellow: # 전체 격자 수와 노란색의 수가 맞으면 정답
                return [w, h]
```
### 설명
본 문제는 완전 탐색을 통하여 가로와 세로의 길이를 변동시켜가며 문제를 해결할 수 있다. 먼저 가로와 세로가 가능한 범위를 알아야 한다. 가능한 가장 작은 크기의 카펫은 다음과 같이 [3, 3] 크기의 
카펫이다.  
![가장 작은 카펫](https://user-images.githubusercontent.com/77680436/108178998-6f128200-7148-11eb-91fa-65688acbec40.png)

따라서 가로와 세로 모두 최솟값은 3이 된다. 가로의 최댓값은 세로가 최소일 때가 되는데, 세로의 최소가 3이므로 갈색으로 만들 수 있는 최대의 가로 크기는 (brown/2) - 1이다. 이는 아래의 사진을 보면 
쉽게 이해할 수 있다.

![가로 최대 예시](https://user-images.githubusercontent.com/77680436/108183736-bd764f80-714d-11eb-9856-747568964cd8.gif)

위와 같이 갈색을 가지고 세로가 3인 사각형을 만들기 위해, 가로를 반으로 나누고, 세로의 빈공간 채워주기 위해 각 가로마다 하나씩 빼서 채워준다. 따라서 최대로 가능한 가로의 크기는 
(brown/2) - 1이다.

세로의 경우 제한사항에서 '카펫의 가로 길이는 세로 길이와 같거나, 세로 길이보다 깁니다.'라고 하고 있으므로 최소는 3, 최대는 가로의 크기가 된다.

이제 문제의 조건을 만족하는지 확인하기 위해 조건식을 세워야 하는데, 먼저 해당 가로, 세로의 크기로 만든 사각형의 격자 수가 갈색과 노란색 격자의 합과 같은지 확인해주면 된다. 예를 들어
첫 번째 예시의 경우 4x3의 크기는 12개의 격자로 나뉘어지는데, 이는 10(갈색)+2(노란색)의 결과와 같다. 전체 격자의 수가 일치하면, 이제 노란색의 수가 정확히 맞는지 확인해주면 된다. 문제에서 
갈색은 노란색의 테두리로 한 줄이 칠해져있다고 한다. 따라서 노란색의 경우 갈색보다 가로와 세로가 2가 작아야 한다.

이러한 두 조건을 성립한다면 문제에서 요구하는 전체 카펫의 가로, 세로 크기가 된다.

## 개선사항
본 문제가 완전탐색 문제로 분류되어 있어 당연히 가능한 모든 경우를 확인할 것이라고 생각하여, 너무 고민 없이 직관적으로 문제를 풀었다. 하지만 제출답안보다 훨씬 최적화된 방법이 존재한다. 
제출답안에서는 직관적으로 w와 h에 대해 2중 for 문을 돌았다. 그렇지만 실제로는 for 문 한 개로도 가능하다.

위에서 말 했듯이 제출답안에서는 가로, 세로에 대해 2중 for 문을 돌고 ```w*h == brown+yellow```라는 조건을 통하여 먼저 1차적인 후보를 정하였다. 
하지만 이보다는 가로나 세로 하나에 대해서만 for 문을 돌고 전체 격자의 수가 이에 나누어 떨어지는지 확인 하는 방법으로 1차적인 후보를 정하는 것이 더 효율적이다.

먼저 최종적으로 개선된 코드를 보면 다음과 같다.
```python
def solution(brown, yellow):
    total = brown+yellow # 전체 격자의 수
    for w in range(brown//2-1, 2, -1): # 가로가 더 크거나 같으므로 역순
        if not total % w: # 가능한 후보라면
            h = total // w
            if (w-2)*(h-2) == yellow: # 해당 크기를 적용했을 때, 노란색의 수가 일치하는지 확인
                return [w, h]
```
위와 같이 전체 격자의 수가 가로의 수로 나누어 떨어진다면(if not total % w), 이는 가로의 수에 적절한 값을 곱하면 전체 격자의 수를 만들 수 있다는 것을 의미한다. 즉, 이때 말하는 적절한 값은 
높이 후보가 된다.(후보 값은 total // w) 따라서 이때의 w를 가로, h를 높이로 가정할 수 있고, 이는 ```w*h == brown+yellow```의 조건을 대체할 수 있다. 따라서 가능한 가로, 세로 후보를 정했다면 아까와 같이 
```(w-2)*(h-2) == yellow```의 조건을 통해 완전히 성립하는지만 확인해준다면 이는 문제에서 요하는 답이 된다.

다음은 실제 예를 살펴보자. 예를 들어서 첫 번째 예시를 살펴보면, 전체 격자의 수가 12이다. 따라서 가능한 가로, 세로의 후보는 다음과 같다.

1. [12, 1]
2. [6, 2]
3. [4, 3]
4. [3, 4]
5. [2, 6]
6. [1, 12]

이때, 가로는 최소 3, 최대 brown/2-1 이므로 실제 for문이 돌아가는 후보는 다음과 같다.

1. [4, 3]
2. [3, 4]

이처럼 가로와 세로가 바뀐 대칭적인 후보가 모두 존재한다. 가로를 최댓값부터 감소하는 방향으로 진행한 것은 이러한 후보 중 가로 값을 더 크거나 같게 하도록 하기 위함이다. 대칭적인 후보가 모두 
존재하더라도 가로가 큰 경우가 먼저 성립되기 때문에 세로가 큰 후보를 탐색하기도 전에 함수는 종료되게 되어있다.
