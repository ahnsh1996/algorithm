# [프로그래머스] 전화번호 목록
## 문제
### 문제 설명
([원본 문제](https://programmers.co.kr/learn/courses/30/lessons/42577)의 내용을 복사한 것입니다.)

전화번호부에 적힌 전화번호 중, 한 번호가 다른 번호의 접두어인 경우가 있는지 확인하려 합니다.
전화번호가 다음과 같을 경우, 구조대 전화번호는 영석이의 전화번호의 접두사입니다.

* 구조대 : 119
* 박준영 : 97 674 223
* 지영석 : 11 9552 4421

전화번호부에 적힌 전화번호를 담은 배열 phone_book 이 solution 함수의 매개변수로 주어질 때, 어떤 번호가 다른 번호의 접두어인 경우가 있으면 false를 그렇지 않으면 true를 return 하도록 solution 함수를 작성해주세요.

### 제한사항
* phone_book의 길이는 1 이상 1,000,000 이하입니다.
* 각 전화번호의 길이는 1 이상 20 이하입니다.

### 입출력 예
|phone_book|return|
|:---:|:---:|
|["119", "97674223", "1195524421"]|false|
|["123", "456", "789"]|true|
|["12", "123", "1235", "567", "88"]|false|

### 입출력 예 설명
입출력 예 #1  
앞에서 설명한 예와 같습니다.

입출력 예 #2  
한 번호가 다른 번호의 접두사인 경우가 없으므로, 답은 true입니다.

입출력 예 #3  
첫 번째 전화번호, “12”가 두 번째 전화번호 “123”의 접두사입니다. 따라서 답은 false입니다.

## 제출답안
```python
def solution(phone_book):
    dic = dict.fromkeys(phone_book, 1) # 전화번호를 key로하여 value가 1인 딕셔너리들을 생성(ex. {"119": 1, "112": 1})
    for num in phone_book:
        for i in range(len(num)): # 문자열을 슬라이싱하며 접두사가 존재하는지 찾음
            if dic.get(num[:i+1]):
                if dic.get(num[:i+1]) > 1: return False # 자기 자신을 접두사로 생각하는 것을 방지하기 위하여 2 이상이 경우에만 해당
                dic[num[:i+1]] += 1 # 슬라이싱한 결과가 전화번호부에 있는 경우

    return True
```
### 설명
본 문제는 문자열 슬라이싱을 이용하여 쉽게 구현할 수 있었다. 먼저 전화번호를 key로하여 value가 1인 딕셔너리들을 생성하였다. 이후 반복문을 통해 전화번호를 하나씩 가져와서 앞에서부터 
한 자리씩 추가해가며 해당 전화번호가 전화번호부에 존재하는지 확인하였다. 예를 들어 전화번호부에서 "119"라는 번호를 가져왔다고 하면 다음과 같다.

1. 전화번호부에 "1"이라는 전화번호가 있는지 확인한다.
2. 전화번호부에 "11"이라는 전화번호가 있는지 확인한다.
3. 전화번호부에 "119"이라는 전화번호가 있는지 확인한다.

이런 식으로 전화번호부에 자신의 접두사 번호가 존재하는지 확인하는데, 마지막 3번의 경우 119는 자기 자신이다. 따라서 자기 자신을 고르는 경우를 접두사 번호가 있다고 잘못 판단하는 것을 
방지하기 위하여 전화번호가 있다면 값을 1 증가시키고, 값이 2 이상일 때만 접두사 번호가 존재하는 것으로 판단하였다.

### 개선사항
딕셔너리를 자주 사용하지 않다보니 특정 키가 딕셔너리에 존재하는지 검사하기 위해서 get()함수를 사용하였다. 즉 get() 함수에서 키가 존재하지 않는 경우 None을 반환하는 것을 이용하였는데, 
in 연산이 이와 같은 역할을 할 수 있다는 것을 알게 되었다. 따라서 in 연산을 사용하는 것이 코드 상 더 깔끔할 것 같다. 또한 전화번호의 경우 어차피 같은 전화번호가 존재하지 않기 때문에 
값을 1 증가시키며 자기 자신을 제하는 것보다는 단지 자기 자신과 같지 않은지만 확인하면 더하기 연산을 굳이 수행하지 않아도 된다.

결론적으로 다음과 같이 코드를 수정할 수 있다.
```python
def solution(phone_book):
    dic = dict.fromkeys(phone_book)
    for num in phone_book:
        for i in range(len(num)):
            if num[:i+1] in dic and num[:i+1] != num:
                return False

    return True
```

### 기타
본 문제에서 딕셔너리, 즉 해시 테이블을 이용한 이유는 접두사 번호가 존재하는지 찾는 과정이 더 빠를 것이라고 생각했기 때문이다. 
즉, 해시 테이블에서 조회하는 연산(dic[i]나 i in dic와 같은 연산)은 평균적으로 O(1)임에 반해 문자열의 경우 (아마도)O(n) 이기 때문이다.

하지만 검색 결과 아래와 같이 굳이 해시 테이블을 사용하지 않고 답안을 작성한 경우가 훨씬 빠른 결과를 가져오는 것을 볼 수 있었다.(+ 문자열 슬라이싱보다는 문자열을 하나씩 더하는 경우가 더 
빨랐음)
```python
def solution(phone_book):
    for num in phone_book:
        temp = ''
        for i in num:
            temp += i
            if temp in phone_book and temp != num:
                return False

    return True
```
사실 아직 정확한 원인을 찾지 못 하였지만, 이는 전화번호부의 길이에 따라 딕셔너리를 만드는 과정이 더 시간이 오래 소요됐거나 파이썬에서만의 차이이거나 등의 원인 때문일 것 같다. 
따라서 자세한 이유는 조금 더 생각해 볼 예정이다.
